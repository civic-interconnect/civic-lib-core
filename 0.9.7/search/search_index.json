{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Lib Core Documentation","text":"<p>Documentation for Civic Lib Core.</p> <p>Use the navigation menu to explore available modules and APIs.</p> <ul> <li>The API Reference section includes autogenerated docs from the source code.</li> <li>This home page will always be served at <code>/</code>.</li> </ul> <p>To learn more, visit the GitHub repository.</p>"},{"location":"api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"api/#civic_lib_core","title":"civic_lib_core","text":"<p>Civic Interconnect shared utilities package.</p>"},{"location":"api/#civic_lib_core.cli","title":"cli","text":""},{"location":"api/#civic_lib_core.cli.__main__","title":"__main__","text":"<p>Entry point for Civic Dev CLI.</p> <p>File: cli.main</p>"},{"location":"api/#civic_lib_core.cli.build_api","title":"build_api","text":"<p>Generate and update application interface documentation using pdoc.</p> <p>This script: - Locates the project root - Discovers local Python packages to document - Generates standalone HTML API documentation - Writes HTML files into the docs/api/ folder (or configured docs_api_dir)</p> <p>File cli/build_api.py</p>"},{"location":"api/#civic_lib_core.cli.build_api.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Generate standalone HTML API documentation using pdoc.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exit code (0 if successful, nonzero otherwise)</p> Source code in <code>src/civic_lib_core/cli/build_api.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Generate standalone HTML API documentation using pdoc.\n\n    Returns:\n        int: exit code (0 if successful, nonzero otherwise)\n    \"\"\"\n    logger.info(\"Generating API documentation with pdoc...\")\n\n    # Discover the project layout (includes paths and package info)\n    layout = project_layout.discover_project_layout()\n\n    output_dir = layout.docs_api_dir\n    if not output_dir:\n        logger.error(\"No output directory configured for API documentation.\")\n        return 1\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    # Convert list of package Paths \u2192 dotted module names\n    packages = _packages_as_module_names(layout.packages, layout.src_dir)\n\n    if not packages:\n        logger.warning(\"No Python packages found to document.\")\n        return 0\n\n    logger.info(f\"Packages discovered for API docs: {', '.join(packages)}\")\n\n    # Validate packages before building command\n    validation_error = _validate_packages(packages)\n    if validation_error:\n        return validation_error\n\n    # Build and validate pdoc command\n    cmd = _build_pdoc_command(packages, output_dir)\n    validation_error = _validate_command(cmd, output_dir)\n    if validation_error:\n        return validation_error\n\n    # Execute pdoc command\n    return _execute_pdoc_command(cmd, output_dir)\n</code></pre>"},{"location":"api/#civic_lib_core.cli.bump_version","title":"bump_version","text":"<p>Command-line tool to update version strings across key project files.</p> <p>This tool replaces the old version with the new version in: - VERSION - pyproject.toml - README.md</p> Usage <p>python -m cli.bump_version OLD_VERSION NEW_VERSION or as a subcommand: <code>civic-dev bump-version OLD_VERSION NEW_VERSION</code> or shorthand: <code>civic-dev bump OLD_VERSION NEW_VERSION</code></p> <p>File:   bump_version.py Module: cli.bump_version</p>"},{"location":"api/#civic_lib_core.cli.bump_version.bump_version_cmd","title":"bump_version_cmd","text":"<pre><code>bump_version_cmd(old_version: str, new_version: str) -&gt; int\n</code></pre> <p>CLI subcommand handler for version bump.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code (0 on success, 1 if no updates).</p> Source code in <code>src/civic_lib_core/cli/bump_version.py</code> <pre><code>def bump_version_cmd(old_version: str, new_version: str) -&gt; int:\n    \"\"\"CLI subcommand handler for version bump.\n\n    Returns:\n        int: Exit code (0 on success, 1 if no updates).\n    \"\"\"\n    updated = _bump_version(old_version, new_version)\n    if updated:\n        logger.info(f\"{updated} file(s) updated.\")\n        return 0\n    logger.info(\"No files were updated.\")\n    return 1\n</code></pre>"},{"location":"api/#civic_lib_core.cli.bump_version.main","title":"main","text":"<pre><code>main(old_version: str, new_version: str) -&gt; int\n</code></pre> <p>Script-style entry point.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code.</p> Source code in <code>src/civic_lib_core/cli/bump_version.py</code> <pre><code>def main(old_version: str, new_version: str) -&gt; int:\n    \"\"\"Script-style entry point.\n\n    Returns:\n        int: Exit code.\n    \"\"\"\n    return bump_version_cmd(old_version, new_version)\n</code></pre>"},{"location":"api/#civic_lib_core.cli.bump_version.update_file","title":"update_file","text":"<pre><code>update_file(path: Path, old: str, new: str) -&gt; bool\n</code></pre> <p>Replace version string in the specified file if found.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if file was modified, False otherwise.</p> Source code in <code>src/civic_lib_core/cli/bump_version.py</code> <pre><code>def update_file(path: Path, old: str, new: str) -&gt; bool:\n    \"\"\"Replace version string in the specified file if found.\n\n    Returns:\n        bool: True if file was modified, False otherwise.\n    \"\"\"\n    if not path.exists():\n        logger.info(f\"Skipping: {path} (not found)\")\n        return False\n\n    content = path.read_text(encoding=\"utf-8\")\n    updated = content.replace(old, new)\n\n    if content != updated:\n        path.write_text(updated, encoding=\"utf-8\")\n        logger.info(f\"Updated: {path}\")\n        return True\n    logger.info(f\"No changes needed in: {path}\")\n    return False\n</code></pre>"},{"location":"api/#civic_lib_core.cli.check_policy","title":"check_policy","text":"<p>CLI utility to check Civic Interconnect project policy compliance.</p>"},{"location":"api/#civic_lib_core.cli.check_policy.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Check current repo against Civic Interconnect policy.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>exit code (0 = OK, nonzero = errors)</p> Source code in <code>src/civic_lib_core/cli/check_policy.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Check current repo against Civic Interconnect policy.\n\n    Returns:\n        int: exit code (0 = OK, nonzero = errors)\n    \"\"\"\n    try:\n        repo_root = fs_utils.get_project_root()\n\n        # Default to python for now\n        repo_type = \"python\"\n\n        issues = policy_utils.check_policy(repo_root, repo_type)\n\n        if issues:\n            print(\"Policy check failed with issues:\")\n            for issue in issues:\n                print(f\"  - {issue}\")\n            return 1\n        print(\"Policy check passed. All required files/directories exist.\")\n        return 0\n\n    except Exception as e:\n        logger.error(f\"Failed to check project policy: {e}\")\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli","title":"cli","text":"<p>Developer command-line interface (CLI) for Civic Interconnect projects.</p> <p>Provides cross-repo automation commands for: - Installing and verifying the local development environment - Formatting, linting, and testing the codebase - Bumping version numbers for release - Tagging and pushing release commits</p> <p>Run <code>civic-dev --help</code> for usage across all Civic Interconnect repos.</p> <p>File: cli.py</p>"},{"location":"api/#civic_lib_core.cli.cli.build_api_command","title":"build_api_command","text":"<pre><code>build_api_command()\n</code></pre> <p>Build the docs.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"build-api\")  # type: ignore\ndef build_api_command():\n    \"\"\"Build the docs.\"\"\"\n    build_api.main()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.bump_version_command","title":"bump_version_command","text":"<pre><code>bump_version_command(old_version: str, new_version: str)\n</code></pre> <p>Update version strings across the project.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"bump-version\")  # type: ignore\ndef bump_version_command(old_version: str, new_version: str):\n    \"\"\"Update version strings across the project.\"\"\"\n    return bump_version.main(old_version, new_version)\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.check_policy_command","title":"check_policy_command","text":"<pre><code>check_policy_command()\n</code></pre> <p>Check policies.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"check-policy\")  # type: ignore\ndef check_policy_command():\n    \"\"\"Check policies.\"\"\"\n    check_policy.main()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.layout_command","title":"layout_command","text":"<pre><code>layout_command()\n</code></pre> <p>Show the current project layout.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"layout\")  # type: ignore\ndef layout_command():\n    \"\"\"Show the current project layout.\"\"\"\n    layout.main()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Entry point for the CLI application.</p> <p>This function serves as the main entry point that initializes and runs the CLI application using the app() function.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>def main():\n    \"\"\"Entry point for the CLI application.\n\n    This function serves as the main entry point that initializes and runs the\n    CLI application using the app() function.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.prepare_code","title":"prepare_code","text":"<pre><code>prepare_code()\n</code></pre> <p>Format, lint, and test the codebase.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"prep-code\")  # type: ignore\ndef prepare_code():\n    \"\"\"Format, lint, and test the codebase.\"\"\"\n    prep_code.main()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.cli.release_command","title":"release_command","text":"<pre><code>release_command()\n</code></pre> <p>Tag and push the current version to GitHub.</p> Source code in <code>src/civic_lib_core/cli/cli.py</code> <pre><code>@app.command(\"release\")  # type: ignore\ndef release_command():\n    \"\"\"Tag and push the current version to GitHub.\"\"\"\n    release.main()\n</code></pre>"},{"location":"api/#civic_lib_core.cli.layout","title":"layout","text":"<p>CLI utility to discover and print the Civic Interconnect project layout.</p> <p>File: layout.py</p>"},{"location":"api/#civic_lib_core.cli.layout.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Discover and print the project layout.</p> <p>Prints a formatted summary of: - Project root - Docs directories - Source packages - Organization name - Policy file used</p> Source code in <code>src/civic_lib_core/cli/layout.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Discover and print the project layout.\n\n    Prints a formatted summary of:\n    - Project root\n    - Docs directories\n    - Source packages\n    - Organization name\n    - Policy file used\n    \"\"\"\n    try:\n        layout = project_layout.discover_project_layout()\n        print()\n        print(project_layout.format_layout(layout))\n    except Exception as e:\n        logger.error(f\"Failed to discover project layout: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"api/#civic_lib_core.cli.prep_code","title":"prep_code","text":"<p>Prepare Civic Interconnect code for release or commit.</p> <p>This script: - Checks whether the virtual environment may be stale (based on dependency file timestamps) - Formats code using Ruff - Lints and fixes issues with Ruff - Runs pre-commit hooks twice (first to fix, then to verify) - Executes unit tests via pytest</p> <p>If dependency files changed since .venv was created, the script warns the user to rerun their setup script (e.g. setup.ps1) to reinstall the environment.</p> <p>File: prep_code.py</p>"},{"location":"api/#civic_lib_core.cli.prep_code.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Prepare code using a comprehensive workflow.</p> <p>This function performs a comprehensive code preparation workflow including: - Virtual environment validation and dependency checking - Code formatting using Ruff - Linting and automatic fixing of issues - Pre-commit hook execution and validation - Unit test execution</p> <p>The function checks if the virtual environment needs to be reinstalled by comparing dependency file timestamps, then runs a series of code quality tools in sequence. If any step fails, the process is terminated early.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code (0 for success, non-zero for failure). Returns 1 if  virtual environment needs reinstalling, or the return code of  any failed subprocess.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>When any of the code preparation steps                          fail during execution.</p> Source code in <code>src/civic_lib_core/cli/prep_code.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Prepare code using a comprehensive workflow.\n\n    This function performs a comprehensive code preparation workflow including:\n    - Virtual environment validation and dependency checking\n    - Code formatting using Ruff\n    - Linting and automatic fixing of issues\n    - Pre-commit hook execution and validation\n    - Unit test execution\n\n    The function checks if the virtual environment needs to be reinstalled by\n    comparing dependency file timestamps, then runs a series of code quality\n    tools in sequence. If any step fails, the process is terminated early.\n\n    Returns:\n        int: Exit code (0 for success, non-zero for failure). Returns 1 if\n             virtual environment needs reinstalling, or the return code of\n             any failed subprocess.\n\n    Raises:\n        subprocess.CalledProcessError: When any of the code preparation steps\n                                     fail during execution.\n    \"\"\"\n    try:\n        logger.info(\"Checking virtual environment...\")\n\n        if should_reinstall():\n            logger.warning(\n                \"Dependency files changed since the virtual environment was created.\\n\\n\"\n                \"Please rerun your setup script (e.g. setup.ps1) to rebuild your environment.\\n\"\n            )\n            return 1\n        logger.info(\n            \".venv is up-to-date. Skipping environment reinstall. \"\n            \"Rerun your setup script manually if needed.\"\n        )\n\n        # Log the library version for reference\n        lib_version = get_repo_version()\n        logger.info(f\"Current library version: {lib_version}\")\n\n        config_file = Path(\"config.yaml\")\n        if not config_file.exists():\n            logger.warning(\"config.yaml not found \u2014 logger may fall back to defaults.\")\n\n        run_check([\"ruff\", \"format\", \".\"], \"Formatting code with Ruff\")\n        run_check([\"ruff\", \"check\", \".\", \"--fix\"], \"Linting and fixing issues with Ruff\")\n        run_check([\"pre-commit\", \"run\", \"--all-files\"], \"Running pre-commit hooks (allowing fixes)\")\n        run_check([\"pre-commit\", \"run\", \"--all-files\"], \"Verifying pre-commit hooks (must pass)\")\n        run_check([\"pytest\", \"tests\"], \"Running unit tests\")\n\n        logger.info(\"Code formatted, linted, and tested successfully.\")\n        return 0\n\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"Process failed: {e}\")\n        return e.returncode\n</code></pre>"},{"location":"api/#civic_lib_core.cli.prep_code.run_check","title":"run_check","text":"<pre><code>run_check(command: list[str], label: str) -&gt; None\n</code></pre> <p>Run a shell command and fail fast if it errors.</p> Source code in <code>src/civic_lib_core/cli/prep_code.py</code> <pre><code>def run_check(command: list[str], label: str) -&gt; None:\n    \"\"\"Run a shell command and fail fast if it errors.\"\"\"\n    # Validate that the command is from our allowed list of tools\n    allowed_commands = {\"ruff\", \"pre-commit\", \"pytest\"}\n    if not command or command[0] not in allowed_commands:\n        raise ValueError(f\"Untrusted command attempted: {command}\")\n\n    logger.info(f\"{label} ...\")\n    result = subprocess.run(command, shell=False, check=False)  # noqa: S603\n    if result.returncode != 0:\n        logger.error(\n            f\"{label} failed.\\n\\nPlease RE-RUN your setup script to apply and verify all fixes.\\n\"\n        )\n        raise subprocess.CalledProcessError(result.returncode, command)\n</code></pre>"},{"location":"api/#civic_lib_core.cli.prep_code.should_reinstall","title":"should_reinstall","text":"<pre><code>should_reinstall() -&gt; bool\n</code></pre> <p>Determine whether the virtual environment should be reinstalled.</p> <p>Based on timestamps of dependency files.</p> Source code in <code>src/civic_lib_core/cli/prep_code.py</code> <pre><code>def should_reinstall() -&gt; bool:\n    \"\"\"Determine whether the virtual environment should be reinstalled.\n\n    Based on timestamps of dependency files.\n    \"\"\"\n    venv_dir = Path(\".venv\")\n    if not venv_dir.exists():\n        logger.info(\".venv does not exist. A fresh install will be required.\")\n        return True\n\n    venv_time = venv_dir.stat().st_mtime\n    for fname in [\"pyproject.toml\", \"requirements.txt\", \"poetry.lock\"]:\n        path = Path(fname)\n        if path.exists() and path.stat().st_mtime &gt; venv_time:\n            logger.info(f\"Dependency file changed: {fname}\")\n            return True\n    return False\n</code></pre>"},{"location":"api/#civic_lib_core.cli.release","title":"release","text":"<p>Automate the release process for Civic Interconnect applications.</p> <p>This script: - Reads the version from the VERSION file - Updates pre-commit hooks - Installs the package in editable mode - Formats and lints the code - Generates up-to-date API documentation - Runs pre-commit hooks twice (fix + verify) - Runs unit tests if present - Commits changes if any are staged - Creates a new Git tag for the release - Pushes the commit and tag to the remote repository</p> <p>Update the VERSION file before running this script.</p> <p>File: release.py</p> Example <p>civic-dev bump-version 1.0.3 1.0.4</p>"},{"location":"api/#civic_lib_core.cli.release.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Complete the release workflow for the current version.</p> Source code in <code>src/civic_lib_core/cli/release.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Complete the release workflow for the current version.\"\"\"\n    version_path = Path(\"VERSION\")\n    if not version_path.exists():\n        logger.error(\"VERSION file not found.\")\n        return 1\n\n    version = version_path.read_text().strip().removeprefix(\"v\")\n    tag = f\"v{version}\"\n    logger.info(f\"Releasing version {tag}\")\n\n    try:\n        _validate_tag(tag)\n        git_path = _validate_git_executable()\n\n        _setup_and_format()\n        _run_precommit_and_tests()\n        _commit_and_tag(tag, git_path)\n\n        logger.info(f\"Release {tag} completed successfully\")\n        return 0\n\n    except Exception as e:\n        logger.error(f\"Release process failed: {e}\")\n        return 1\n</code></pre>"},{"location":"api/#civic_lib_core.cli.release.run","title":"run","text":"<pre><code>run(cmd: str, check: bool = True) -&gt; None\n</code></pre> <p>Run a shell command and log it.</p> Source code in <code>src/civic_lib_core/cli/release.py</code> <pre><code>def run(cmd: str, check: bool = True) -&gt; None:\n    \"\"\"Run a shell command and log it.\"\"\"\n    # Define allowed commands for security\n    allowed_commands = {\"pre-commit\", \"uv\", \"pip\", \"ruff\", \"pytest\", \"git\"}\n\n    # Parse and validate the command\n    cmd_parts = shlex.split(cmd)\n    if not cmd_parts:\n        raise RuntimeError(\"Empty command\")\n\n    base_command = cmd_parts[0]\n    if base_command not in allowed_commands:\n        raise RuntimeError(f\"Command not allowed: {base_command}\")\n\n    # Additional validation for command arguments\n    for arg in cmd_parts:\n        if not all(c.isalnum() or c in \".-_/:=[]\\\"'\" for c in arg):\n            raise RuntimeError(f\"Unsafe argument detected: {arg}\")\n\n    logger.info(f\"$ {cmd}\")\n    result = subprocess.run(cmd_parts, shell=False, check=False)  # noqa: S603\n    if check and result.returncode != 0:\n        raise RuntimeError(f\"Command failed: {cmd}\")\n</code></pre>"},{"location":"api/#civic_lib_core.config_utils","title":"config_utils","text":"<p>civic_lib_core/config_utils.py.</p> <p>Utilities for managing configuration and environment data in Civic Interconnect projects.</p> <p>Provides: - Loading environment-based API keys - Reading YAML configuration files - Reading project version information - Parsing version strings into numeric tuples</p> <p>Typical usage:</p> <pre><code>from civic_lib_core import config_utils\n\napi_key = config_utils.load_api_key(\"MY_API_KEY\", \"MyService\")\nconfig = config_utils.load_yaml_config()\nversion = config_utils.load_version()\nmajor, minor, patch = config_utils.parse_version(\"1.2.3\")\n</code></pre>"},{"location":"api/#civic_lib_core.config_utils.load_api_key","title":"load_api_key","text":"<pre><code>load_api_key(env_var: str, service_name: str) -&gt; str\n</code></pre> <p>Load an API key from the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>env_var</code> <code>str</code> <p>Name of the environment variable.</p> required <code>service_name</code> <code>str</code> <p>Friendly name for error messaging.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The API key value.</p> Exits <p>If the environment variable is missing or empty.</p> Source code in <code>src/civic_lib_core/config_utils.py</code> <pre><code>def load_api_key(env_var: str, service_name: str) -&gt; str:\n    \"\"\"Load an API key from the environment variables.\n\n    Args:\n        env_var (str): Name of the environment variable.\n        service_name (str): Friendly name for error messaging.\n\n    Returns:\n        str: The API key value.\n\n    Exits:\n        If the environment variable is missing or empty.\n    \"\"\"\n    key = (os.getenv(env_var) or \"\").strip()\n    if not key:\n        logger.error(\n            f\"Missing API key for {service_name}. \"\n            f\"Fix: add {env_var!r} to your .env file or system environment.\"\n        )\n        sys.exit(f\"Error: Environment variable {env_var} is required for {service_name}.\")\n    return key\n</code></pre>"},{"location":"api/#civic_lib_core.config_utils.load_version","title":"load_version","text":"<pre><code>load_version(filename: str = 'VERSION', root_dir: Path | None = None) -&gt; str\n</code></pre> <p>Load the version string from a VERSION file in the project.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the version file.</p> <code>'VERSION'</code> <code>root_dir</code> <code>Optional[Path]</code> <p>Base directory to search from.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Version string like \"1.2.3\".</p> Exits <p>If the file is missing or unreadable.</p> Source code in <code>src/civic_lib_core/config_utils.py</code> <pre><code>def load_version(filename: str = \"VERSION\", root_dir: Path | None = None) -&gt; str:\n    \"\"\"Load the version string from a VERSION file in the project.\n\n    Args:\n        filename (str): Name of the version file.\n        root_dir (Optional[Path]): Base directory to search from.\n\n    Returns:\n        str: Version string like \"1.2.3\".\n\n    Exits:\n        If the file is missing or unreadable.\n    \"\"\"\n    root = root_dir or fs_utils.get_project_root()\n    version_path = root / filename\n\n    try:\n        version = version_path.read_text(encoding=\"utf-8\").strip()\n        logger.info(f\"Loaded version: {version}\")\n        return version\n    except Exception as e:\n        logger.error(f\"Error reading VERSION file at {version_path}: {e}\")\n        sys.exit(f\"Error: VERSION file missing or unreadable at {version_path}.\")\n</code></pre>"},{"location":"api/#civic_lib_core.config_utils.load_yaml_config","title":"load_yaml_config","text":"<pre><code>load_yaml_config(filename: str = 'config.yaml', root_dir: Path | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Load a YAML configuration file from the project root.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the YAML file.</p> <code>'config.yaml'</code> <code>root_dir</code> <code>Optional[Path]</code> <p>Base directory to search from.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Parsed configuration dictionary.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If config file is missing.</p> Source code in <code>src/civic_lib_core/config_utils.py</code> <pre><code>def load_yaml_config(filename: str = \"config.yaml\", root_dir: Path | None = None) -&gt; dict[str, Any]:\n    \"\"\"Load a YAML configuration file from the project root.\n\n    Args:\n        filename (str): Name of the YAML file.\n        root_dir (Optional[Path]): Base directory to search from.\n\n    Returns:\n        dict[str, Any]: Parsed configuration dictionary.\n\n    Raises:\n        FileNotFoundError: If config file is missing.\n    \"\"\"\n    root = root_dir or fs_utils.get_project_root()\n    config_path = root / filename\n\n    if not config_path.exists():\n        msg = f\"Config file not found: {config_path}\"\n        logger.error(msg)\n        raise FileNotFoundError(msg)\n\n    with config_path.open(encoding=\"utf-8\") as f:\n        config = yaml.safe_load(f) or {}\n\n    logger.debug(f\"Loaded config from {config_path}\")\n    return config\n</code></pre>"},{"location":"api/#civic_lib_core.config_utils.parse_version","title":"parse_version","text":"<pre><code>parse_version(version: str) -&gt; tuple[int, int, int]\n</code></pre> <p>Parse a version string (e.g. \"1.2.3\") into a tuple of integers.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Version string.</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: Tuple of (major, minor, patch).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the version format is invalid.</p> Source code in <code>src/civic_lib_core/config_utils.py</code> <pre><code>def parse_version(version: str) -&gt; tuple[int, int, int]:\n    \"\"\"Parse a version string (e.g. \"1.2.3\") into a tuple of integers.\n\n    Args:\n        version (str): Version string.\n\n    Returns:\n        tuple[int, int, int]: Tuple of (major, minor, patch).\n\n    Raises:\n        ValueError: If the version format is invalid.\n    \"\"\"\n    match = re.match(r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\", version)\n    if not match:\n        raise ValueError(f\"Invalid version format: {version}\")\n    major, minor, patch = match.groups()\n    return int(major), int(minor), int(patch)\n</code></pre>"},{"location":"api/#civic_lib_core.date_utils","title":"date_utils","text":"<p>civic_lib_core/date_utils.py.</p> <p>Date and time utilities for Civic Interconnect projects.</p> <p>Provides helpers to: - Generate date ranges for reports - Retrieve current UTC time or date - Format UTC datetimes into strings</p> <p>Typical usage:</p> <pre><code>from civic_lib_core import date_utils\n\n# Get today's UTC date string\ntoday = date_utils.today_utc_str()\n\n# Get current UTC datetime as a string\ntimestamp = date_utils.now_utc_str()\n\n# Generate list of dates for the past 7 days\ndates = date_utils.date_range(7)\n</code></pre>"},{"location":"api/#civic_lib_core.date_utils.date_range","title":"date_range","text":"<pre><code>date_range(days_back: int) -&gt; list[str]\n</code></pre> <p>Generate a list of date strings from <code>days_back</code> days ago up to today (UTC).</p> <p>Parameters:</p> Name Type Description Default <code>days_back</code> <code>int</code> <p>Number of days to include, ending with today (inclusive).              For example, days_back=7 returns 7 dates.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of UTC dates in 'YYYY-MM-DD' format, earliest to latest.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If days_back is negative.</p> Source code in <code>src/civic_lib_core/date_utils.py</code> <pre><code>def date_range(days_back: int) -&gt; list[str]:\n    \"\"\"Generate a list of date strings from `days_back` days ago up to today (UTC).\n\n    Args:\n        days_back (int): Number of days to include, ending with today (inclusive).\n                         For example, days_back=7 returns 7 dates.\n\n    Returns:\n        list[str]: List of UTC dates in 'YYYY-MM-DD' format, earliest to latest.\n\n    Raises:\n        ValueError: If days_back is negative.\n    \"\"\"\n    if days_back &lt; 0:\n        raise ValueError(\"days_back must be non-negative\")\n\n    if days_back == 0:\n        return []\n\n    today = now_utc().date()\n    start_date = today - timedelta(days=days_back - 1)\n    return [(start_date + timedelta(days=i)).strftime(\"%Y-%m-%d\") for i in range(days_back)]\n</code></pre>"},{"location":"api/#civic_lib_core.date_utils.now_utc","title":"now_utc","text":"<pre><code>now_utc() -&gt; datetime\n</code></pre> <p>Return the current UTC datetime object.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>Current UTC datetime.</p> Source code in <code>src/civic_lib_core/date_utils.py</code> <pre><code>def now_utc() -&gt; datetime:\n    \"\"\"Return the current UTC datetime object.\n\n    Returns:\n        datetime: Current UTC datetime.\n    \"\"\"\n    return datetime.now(UTC)\n</code></pre>"},{"location":"api/#civic_lib_core.date_utils.now_utc_str","title":"now_utc_str","text":"<pre><code>now_utc_str(fmt: str = '%Y-%m-%d %H:%M:%S UTC') -&gt; str\n</code></pre> <p>Return the current time in UTC as a formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Format string for datetime output. Default includes 'UTC'.</p> <code>'%Y-%m-%d %H:%M:%S UTC'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted current UTC time.</p> Source code in <code>src/civic_lib_core/date_utils.py</code> <pre><code>def now_utc_str(fmt: str = \"%Y-%m-%d %H:%M:%S UTC\") -&gt; str:\n    \"\"\"Return the current time in UTC as a formatted string.\n\n    Args:\n        fmt (str): Format string for datetime output. Default includes 'UTC'.\n\n    Returns:\n        str: Formatted current UTC time.\n    \"\"\"\n    return now_utc().strftime(fmt)\n</code></pre>"},{"location":"api/#civic_lib_core.date_utils.today_utc_str","title":"today_utc_str","text":"<pre><code>today_utc_str() -&gt; str\n</code></pre> <p>Return today's date in UTC in 'YYYY-MM-DD' format.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Current UTC date as a string.</p> Source code in <code>src/civic_lib_core/date_utils.py</code> <pre><code>def today_utc_str() -&gt; str:\n    \"\"\"Return today's date in UTC in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: Current UTC date as a string.\n    \"\"\"\n    return now_utc().strftime(\"%Y-%m-%d\")\n</code></pre>"},{"location":"api/#civic_lib_core.dev_utils","title":"dev_utils","text":"<p>civic_lib_core/dev_utils.py.</p> <p>Core development utilities. Part of the Civic Interconnect agent framework.</p>"},{"location":"api/#civic_lib_core.dev_utils.log_suggested_paths","title":"log_suggested_paths","text":"<pre><code>log_suggested_paths(response: Any, max_depth: int = 3, source_label: str = 'response') -&gt; None\n</code></pre> <p>Log inferred paths to nested keys in a response object.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Any</code> <p>Parsed API response.</p> required <code>max_depth</code> <code>int</code> <p>Maximum depth to explore.</p> <code>3</code> <code>source_label</code> <code>str</code> <p>Label for context in logs.</p> <code>'response'</code> Source code in <code>src/civic_lib_core/dev_utils.py</code> <pre><code>def log_suggested_paths(\n    response: Any,\n    max_depth: int = 3,\n    source_label: str = \"response\",\n) -&gt; None:\n    \"\"\"Log inferred paths to nested keys in a response object.\n\n    Args:\n        response (Any): Parsed API response.\n        max_depth (int): Maximum depth to explore.\n        source_label (str): Label for context in logs.\n    \"\"\"\n    logger.info(f\"Suggested paths in {source_label}:\")\n\n    if isinstance(response, Mapping):\n        logger.info(f\"Top-level keys: {sorted(response.keys())}\")\n        paths = suggest_paths(response, max_depth=max_depth)\n        for path, key, value in paths:\n            logger.info(f\"Path: {' -&gt; '.join(path)} | Final Key: {key} | Value: {value}\")\n    elif isinstance(response, Sequence) and not isinstance(response, str | bytes):\n        logger.info(f\"Top-level object is a list with {len(response)} items.\")\n        for i, item in enumerate(response[:5]):\n            logger.info(f\"Index {i}: {type(item).__name__}\")\n    else:\n        logger.warning(\"Response is neither a dict nor a list; cannot analyze paths.\")\n</code></pre>"},{"location":"api/#civic_lib_core.dev_utils.suggest_paths","title":"suggest_paths","text":"<pre><code>suggest_paths(response: Any, max_depth: int = 3, current_path: list[str] | None = None) -&gt; list[tuple[list[str], str, str]]\n</code></pre> <p>Suggest possible nested data paths in a response object.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Any</code> <p>Parsed API response.</p> required <code>max_depth</code> <code>int</code> <p>Maximum traversal depth.</p> <code>3</code> <code>current_path</code> <code>list[str] | None</code> <p>Used internally for recursion.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[list[str], str, str]]</code> <p>list of (path, key, summary): Potential paths to explore.</p> Source code in <code>src/civic_lib_core/dev_utils.py</code> <pre><code>def suggest_paths(\n    response: Any,\n    max_depth: int = 3,\n    current_path: list[str] | None = None,\n) -&gt; list[tuple[list[str], str, str]]:\n    \"\"\"Suggest possible nested data paths in a response object.\n\n    Args:\n        response (Any): Parsed API response.\n        max_depth (int): Maximum traversal depth.\n        current_path (list[str] | None): Used internally for recursion.\n\n    Returns:\n        list of (path, key, summary): Potential paths to explore.\n    \"\"\"\n    if current_path is None:\n        current_path = []\n\n    suggestions: list[tuple[list[str], str, str]] = []\n\n    if max_depth &lt;= 0:\n        return suggestions\n\n    if isinstance(response, Mapping):\n        for key, value in response.items():\n            path = current_path + [key]\n            if isinstance(value, Mapping):\n                suggestions.extend(suggest_paths(value, max_depth - 1, path))\n            elif isinstance(value, list):\n                summary = f\"List[{len(value)}]\" if value else \"List[empty]\"\n                suggestions.append((path, key, summary))\n            else:\n                suggestions.append((path, key, str(value)))\n    elif isinstance(response, list):\n        summary = f\"List[{len(response)}]\" if response else \"List[empty]\"\n        suggestions.append((current_path, \"[list]\", summary))\n\n    return suggestions\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils","title":"fs_utils","text":"<p>civic_lib_core/fs_utils.py.</p> <p>File and path utility functions for root-relative logic. Unified utilities used across Civic Interconnect agents and libraries.</p>"},{"location":"api/#civic_lib_core.fs_utils.discover_project_layout","title":"discover_project_layout","text":"<pre><code>discover_project_layout() -&gt; ProjectLayout\n</code></pre> <p>Discover and analyze the project layout structure.</p> <p>Scans the project directory to identify key components including the project root, documentation directories, source code location, valid packages, organization name, and project policy configuration.</p> <p>Returns:</p> Name Type Description <code>ProjectLayout</code> <code>ProjectLayout</code> <p>A comprehensive object containing all discovered project structure information including: - project_root: The root directory of the project - docs_dir: Main documentation directory - docs_api_dir: API documentation directory - src_dir: Source code directory - packages: List of valid Python packages found - org_name: Organization name associated with the project - policy: Loaded project policy configuration</p> Note <p>This function performs automatic discovery and may return empty collections or None values for components that are not found or configured in the project.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def discover_project_layout() -&gt; ProjectLayout:\n    \"\"\"Discover and analyze the project layout structure.\n\n    Scans the project directory to identify key components including the project root,\n    documentation directories, source code location, valid packages, organization name,\n    and project policy configuration.\n\n    Returns:\n        ProjectLayout: A comprehensive object containing all discovered project structure\n            information including:\n            - project_root: The root directory of the project\n            - docs_dir: Main documentation directory\n            - docs_api_dir: API documentation directory\n            - src_dir: Source code directory\n            - packages: List of valid Python packages found\n            - org_name: Organization name associated with the project\n            - policy: Loaded project policy configuration\n\n    Note:\n        This function performs automatic discovery and may return empty collections\n        or None values for components that are not found or configured in the project.\n    \"\"\"\n    root = get_project_root()\n    policy = load_project_policy(root)\n    docs_dir = get_docs_dir(root)\n    docs_api_dir = get_docs_api_dir(root)\n    src = get_source_dir(root)\n    packages = get_valid_packages(src) if src else []\n    org_name = get_org_name(root)\n\n    layout = ProjectLayout(\n        project_root=root,\n        docs_dir=docs_dir,\n        docs_api_dir=docs_api_dir,\n        src_dir=src,\n        packages=packages,\n        org_name=org_name,\n        policy=policy,\n    )\n\n    logger.debug(f\"Discovered project layout: {layout}\")\n    return layout\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.ensure_dir","title":"ensure_dir","text":"<pre><code>ensure_dir(path: str | Path) -&gt; Path\n</code></pre> <p>Ensure a directory exists, creating it and any parent directories if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The directory path to ensure exists. Can be a string or Path object.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The resolved Path object of the created/existing directory.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the directory cannot be created due to permissions or other filesystem issues.</p> Example <p>ensure_dir(\"/path/to/new/directory\") PosixPath('/path/to/new/directory')</p> <p>ensure_dir(Path(\"relative/path\")) PosixPath('/absolute/path/to/relative/path')</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def ensure_dir(path: str | Path) -&gt; Path:\n    \"\"\"Ensure a directory exists, creating it and any parent directories if necessary.\n\n    Args:\n        path (str | Path): The directory path to ensure exists. Can be a string or Path object.\n\n    Returns:\n        Path: The resolved Path object of the created/existing directory.\n\n    Raises:\n        OSError: If the directory cannot be created due to permissions or other filesystem issues.\n\n    Example:\n        &gt;&gt;&gt; ensure_dir(\"/path/to/new/directory\")\n        PosixPath('/path/to/new/directory')\n\n        &gt;&gt;&gt; ensure_dir(Path(\"relative/path\"))\n        PosixPath('/absolute/path/to/relative/path')\n    \"\"\"\n    try:\n        path = Path(path).resolve()\n        path.mkdir(parents=True, exist_ok=True)\n        logger.debug(f\"Ensured directory exists: {path}\")\n        return path\n    except OSError as e:\n        logger.error(f\"Failed to create directory {path}: {e}\")\n        raise\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_data_config_dir","title":"get_data_config_dir","text":"<pre><code>get_data_config_dir(project_root: Path | None = None) -&gt; Path\n</code></pre> <p>Get the data configuration directory path.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path | None</code> <p>The project root directory. If None, uses the discovered project root. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the data-config directory.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_data_config_dir(project_root: Path | None = None) -&gt; Path:\n    \"\"\"Get the data configuration directory path.\n\n    Args:\n        project_root (Path | None, optional): The project root directory.\n            If None, uses the discovered project root. Defaults to None.\n\n    Returns:\n        Path: The path to the data-config directory.\n    \"\"\"\n    root = project_root or get_project_root()\n    return root / \"data-config\"\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_docs_api_dir","title":"get_docs_api_dir","text":"<pre><code>get_docs_api_dir(root_dir: Path | None = None, create: bool = False) -&gt; Path\n</code></pre> <p>Determine the project's API docs subdirectory.</p> <p>Tries: 1. Client repo policy (docs.api_markdown_subdir) 2. Defaults to 'docs/api'</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_docs_api_dir(root_dir: Path | None = None, create: bool = False) -&gt; Path:\n    \"\"\"Determine the project's API docs subdirectory.\n\n    Tries:\n    1. Client repo policy (docs.api_markdown_subdir)\n    2. Defaults to 'docs/api'\n    \"\"\"\n    root_dir = root_dir or get_project_root()\n    docs_dir = get_docs_dir(root_dir)\n    policy = load_project_policy(root_dir)\n\n    api_subdir = policy.get(\"docs\", {}).get(\"api_markdown_subdir\", \"api\")\n    candidate = docs_dir / api_subdir\n\n    logger.debug(f\"API docs dir resolved to: {candidate}\")\n    return ensure_dir(candidate) if create else candidate\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_docs_dir","title":"get_docs_dir","text":"<pre><code>get_docs_dir(root_dir: Path | None = None) -&gt; Path\n</code></pre> <p>Determine the project's main docs directory.</p> <p>Tries: 1. Client repo policy (docs.site_dir or docs.docs_dir) 2. Defaults to 'docs'</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_docs_dir(root_dir: Path | None = None) -&gt; Path:\n    \"\"\"Determine the project's main docs directory.\n\n    Tries:\n    1. Client repo policy (docs.site_dir or docs.docs_dir)\n    2. Defaults to 'docs'\n    \"\"\"\n    root_dir = root_dir or get_project_root()\n    policy = load_project_policy(root_dir)\n\n    docs_dir_name = (\n        policy.get(\"docs\", {}).get(\"site_dir\") or policy.get(\"docs\", {}).get(\"docs_dir\") or \"docs\"\n    )\n    docs_dir = root_dir / docs_dir_name\n\n    if docs_dir.exists() and docs_dir.is_dir():\n        logger.debug(f\"Docs dir found: {docs_dir}\")\n        return docs_dir\n\n    fallback = root_dir / \"docs\"\n    logger.debug(f\"Defaulting docs dir to: {fallback}\")\n    return fallback\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_org_name","title":"get_org_name","text":"<pre><code>get_org_name(project_root: Path) -&gt; str | None\n</code></pre> <p>Get the organization name from the project root's parent directory.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>The root directory path of the project.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The name of the parent directory if it exists, otherwise None.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_org_name(project_root: Path) -&gt; str | None:\n    \"\"\"Get the organization name from the project root's parent directory.\n\n    Args:\n        project_root (Path): The root directory path of the project.\n\n    Returns:\n        str | None: The name of the parent directory if it exists, otherwise None.\n    \"\"\"\n    return project_root.parent.name if project_root.parent and project_root.parent.name else None\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_project_root","title":"get_project_root","text":"<pre><code>get_project_root(start_path: Path | None = None) -&gt; Path\n</code></pre> <p>Find the project root directory by searching for common project markers.</p> <p>Parameters:</p> Name Type Description Default <code>start_path</code> <code>Path | None</code> <p>The starting directory for the search. If None, uses the current working directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The resolved path to the project root directory.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no project root is found by searching upward from the start path.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_project_root(start_path: Path | None = None) -&gt; Path:\n    \"\"\"Find the project root directory by searching for common project markers.\n\n    Args:\n        start_path (Path | None, optional): The starting directory for the search.\n            If None, uses the current working directory. Defaults to None.\n\n    Returns:\n        Path: The resolved path to the project root directory.\n\n    Raises:\n        RuntimeError: If no project root is found by searching upward from the start path.\n    \"\"\"\n    current = start_path or Path.cwd()\n    markers = [\".git\", \"pyproject.toml\"]\n\n    for parent in [current] + list(current.parents):\n        for marker in markers:\n            if (parent / marker).exists():\n                logger.debug(f\"Project root found at: {parent.resolve()} (marker: {marker})\")\n                return parent.resolve()\n\n    raise RuntimeError(\n        f\"Project root not found. Searched from '{current.resolve()}' upward for markers: {markers}.\"\n    )\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_repo_package_names","title":"get_repo_package_names","text":"<pre><code>get_repo_package_names(root_path: Path | None = None) -&gt; list[str]\n</code></pre> <p>Discover all Python package names under the repo's src directory.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Fully qualified package names, e.g. ['civic_lib_core', 'civic_lib_core.cli']</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_repo_package_names(root_path: Path | None = None) -&gt; list[str]:\n    \"\"\"Discover all Python package names under the repo's src directory.\n\n    Returns:\n        List[str]: Fully qualified package names, e.g. ['civic_lib_core', 'civic_lib_core.cli']\n    \"\"\"\n    try:\n        root = root_path or get_project_root()\n        src_dir = get_source_dir(root)\n        if src_dir is None:\n            logger.debug(\"No source directory found, returning empty package list.\")\n            return []\n\n        packages: list[str] = []\n\n        for init_file in src_dir.rglob(\"__init__.py\"):\n            # Compute relative path from src/ to the package folder\n            pkg_path = init_file.parent.relative_to(src_dir)\n            if pkg_path.parts:\n                package_name = \".\".join(pkg_path.parts)\n                packages.append(package_name)\n\n        if not packages:\n            logger.warning(\"No packages discovered under src.\")\n\n        return sorted(packages)\n\n    except Exception as e:\n        logger.warning(f\"Failed to get package names: {e}\")\n        return []\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_runtime_config_path","title":"get_runtime_config_path","text":"<pre><code>get_runtime_config_path(project_root: Path | None = None) -&gt; Path\n</code></pre> <p>Get the runtime configuration file path.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path | None</code> <p>The project root directory. If None, uses the discovered project root. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The path to the runtime_config.yaml file.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_runtime_config_path(project_root: Path | None = None) -&gt; Path:\n    \"\"\"Get the runtime configuration file path.\n\n    Args:\n        project_root (Path | None, optional): The project root directory.\n            If None, uses the discovered project root. Defaults to None.\n\n    Returns:\n        Path: The path to the runtime_config.yaml file.\n    \"\"\"\n    root = project_root or get_project_root()\n    return root / \"runtime_config.yaml\"\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_source_dir","title":"get_source_dir","text":"<pre><code>get_source_dir(root_dir: Path) -&gt; Path | None\n</code></pre> <p>Get the source directory containing Python packages for the project.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>Path</code> <p>The root directory path of the project.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: The path to the source directory if found and contains valid Python packages, otherwise None.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_source_dir(root_dir: Path) -&gt; Path | None:\n    \"\"\"Get the source directory containing Python packages for the project.\n\n    Args:\n        root_dir (Path): The root directory path of the project.\n\n    Returns:\n        Path | None: The path to the source directory if found and contains valid\n            Python packages, otherwise None.\n    \"\"\"\n    policy = load_project_policy(root_dir)\n    src_dirs_config = policy.get(\"build\", {}).get(\"src_dirs\", [\"src\"])\n\n    candidates = []\n    if isinstance(src_dirs_config, str):\n        candidates.append(root_dir / src_dirs_config)\n    elif isinstance(src_dirs_config, list):\n        candidates.extend([root_dir / s for s in src_dirs_config])\n\n    if not candidates and (root_dir / \"src\").is_dir():\n        candidates.append(root_dir / \"src\")\n\n    for candidate in candidates:\n        if candidate.exists() and candidate.is_dir():\n            packages = [p for p in candidate.iterdir() if p.is_dir() and _is_python_package(p)]\n            if packages:\n                logger.debug(\n                    f\"Source directory: {candidate} with packages: {[p.name for p in packages]}\"\n                )\n                return candidate\n\n    logger.warning(\n        f\"No valid source directory with Python packages found in {root_dir} \"\n        f\"based on policy {src_dirs_config} or default 'src'.\"\n    )\n    return None\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.get_valid_packages","title":"get_valid_packages","text":"<pre><code>get_valid_packages(src_dir: Path) -&gt; list[Path]\n</code></pre> <p>Get all valid Python packages found in the source directory.</p> <p>Parameters:</p> Name Type Description Default <code>src_dir</code> <code>Path</code> <p>The source directory to search for Python packages.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: A list of Path objects representing valid Python packages. Returns an empty list if no packages are found or if the source directory doesn't exist.</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def get_valid_packages(src_dir: Path) -&gt; list[Path]:\n    \"\"\"Get all valid Python packages found in the source directory.\n\n    Args:\n        src_dir (Path): The source directory to search for Python packages.\n\n    Returns:\n        list[Path]: A list of Path objects representing valid Python packages.\n            Returns an empty list if no packages are found or if the source\n            directory doesn't exist.\n    \"\"\"\n    if not src_dir.exists() or not src_dir.is_dir():\n        logger.warning(f\"Source directory does not exist or is not a directory: {src_dir}\")\n        return []\n\n    packages = [p for p in src_dir.iterdir() if _is_python_package(p)]\n    if not packages:\n        logger.debug(f\"No valid Python packages found in: {src_dir}\")\n        return []\n\n    logger.debug(f\"Found packages: {[p.name for p in packages]}\")\n    return packages\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.resolve_path","title":"resolve_path","text":"<pre><code>resolve_path(relative_path: str | Path) -&gt; Path\n</code></pre> <p>Resolve a relative path against the project root directory.</p> <p>Parameters:</p> Name Type Description Default <code>relative_path</code> <code>str | Path</code> <p>The relative path to resolve. Can be a string or Path object.</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The resolved absolute path relative to the project root.</p> Example <p>resolve_path(\"src/package\") PosixPath('/absolute/path/to/project/src/package')</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def resolve_path(relative_path: str | Path) -&gt; Path:\n    \"\"\"Resolve a relative path against the project root directory.\n\n    Args:\n        relative_path (str | Path): The relative path to resolve. Can be a string or Path object.\n\n    Returns:\n        Path: The resolved absolute path relative to the project root.\n\n    Example:\n        &gt;&gt;&gt; resolve_path(\"src/package\")\n        PosixPath('/absolute/path/to/project/src/package')\n    \"\"\"\n    root = get_project_root()\n    resolved = (root / Path(relative_path)).resolve()\n    logger.debug(f\"Resolved '{relative_path}' to: {resolved}\")\n    return resolved\n</code></pre>"},{"location":"api/#civic_lib_core.fs_utils.safe_filename","title":"safe_filename","text":"<pre><code>safe_filename(name: str, max_length: int = 255) -&gt; str\n</code></pre> <p>Create a safe filename by sanitizing input string.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The original filename or string to sanitize.</p> required <code>max_length</code> <code>int</code> <p>Maximum length of the resulting filename. Defaults to 255.</p> <code>255</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A sanitized filename safe for filesystem use, containing only alphanumeric characters, dots, underscores, and hyphens. Spaces and path separators are converted to underscores.</p> Example <p>safe_filename(\"My File/Name:Test\") 'my_file_name_test'</p> <p>safe_filename(\"\", 10) 'unnamed'</p> Source code in <code>src/civic_lib_core/fs_utils.py</code> <pre><code>def safe_filename(name: str, max_length: int = 255) -&gt; str:\n    \"\"\"Create a safe filename by sanitizing input string.\n\n    Args:\n        name (str): The original filename or string to sanitize.\n        max_length (int, optional): Maximum length of the resulting filename. Defaults to 255.\n\n    Returns:\n        str: A sanitized filename safe for filesystem use, containing only alphanumeric\n            characters, dots, underscores, and hyphens. Spaces and path separators\n            are converted to underscores.\n\n    Example:\n        &gt;&gt;&gt; safe_filename(\"My File/Name:Test\")\n        'my_file_name_test'\n\n        &gt;&gt;&gt; safe_filename(\"\", 10)\n        'unnamed'\n    \"\"\"\n    if not name:\n        return \"unnamed\"\n\n    safe_chars = []\n    for char in name:\n        if char.isalnum() or char in \"._-\":\n            safe_chars.append(char.lower())\n        elif char in \" /\\\\:\":\n            safe_chars.append(\"_\")\n\n    result = \"\".join(safe_chars)\n    if not result:\n        result = \"file\"\n    if result.startswith(\".\"):\n        result = \"_\" + result\n    if len(result) &gt; max_length:\n        result = result[:max_length].rstrip(\"_\")\n    result = result.rstrip(\"_\") or \"unnamed\"\n\n    logger.debug(f\"Sanitized filename '{name}' to: '{result}'\")\n    return result\n</code></pre>"},{"location":"api/#civic_lib_core.graphql_utils","title":"graphql_utils","text":"<p>civic_lib_core/graphql_utils.py.</p> <p>Unified GraphQL utilities for Civic Interconnect projects.</p> <p>Provides: - Consistent error handling for GraphQL transport errors - Asynchronous and synchronous helpers for paginated GraphQL queries - Utilities to fetch all pages of results from GraphQL APIs</p>"},{"location":"api/#civic_lib_core.graphql_utils.async_paged_query","title":"async_paged_query  <code>async</code>","text":"<pre><code>async_paged_query(url: str, api_key: str, query: Any, data_path: Sequence[str], page_info_path: Sequence[str] | None = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Execute a paginated GraphQL query asynchronously and fetch all results.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GraphQL endpoint URL.</p> required <code>api_key</code> <code>str</code> <p>Bearer token for API authentication.</p> required <code>query</code> <code>Any</code> <p>The GraphQL query object to execute.</p> required <code>data_path</code> <code>Sequence[str]</code> <p>Path to the data array in the response.</p> required <code>page_info_path</code> <code>Sequence[str] | None</code> <p>Path to pageInfo in the response. If None, will attempt to infer from data_path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of all records collected from all pages.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If page_info_path is None and pageInfo cannot be inferred.</p> Source code in <code>src/civic_lib_core/graphql_utils.py</code> <pre><code>async def async_paged_query(\n    url: str,\n    api_key: str,\n    query: Any,\n    data_path: Sequence[str],\n    page_info_path: Sequence[str] | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute a paginated GraphQL query asynchronously and fetch all results.\n\n    Args:\n        url (str): The GraphQL endpoint URL.\n        api_key (str): Bearer token for API authentication.\n        query (Any): The GraphQL query object to execute.\n        data_path (Sequence[str]): Path to the data array in the response.\n        page_info_path (Sequence[str] | None, optional): Path to pageInfo in the response.\n            If None, will attempt to infer from data_path. Defaults to None.\n\n    Returns:\n        list[dict[str, Any]]: List of all records collected from all pages.\n\n    Raises:\n        ValueError: If page_info_path is None and pageInfo cannot be inferred.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    transport = AIOHTTPTransport(url=url, headers=headers, ssl=True)\n\n    async with Client(transport=transport, fetch_schema_from_transport=False) as client:\n        collected: list[dict[str, Any]] = []\n        after = None\n\n        while True:\n            variables = {\"first\": 100, \"after\": after}\n            response = await client.execute(query, variable_values=variables)\n\n            data: Any = response\n            for key in data_path:\n                data = data[key]\n            collected.extend(data)\n\n            if page_info_path is None:\n                try:\n                    page_info: Any = response\n                    for key in data_path[:-1]:\n                        page_info = page_info[key]\n                    page_info = page_info[\"pageInfo\"]\n                except (KeyError, TypeError) as e:\n                    raise ValueError(\n                        \"Could not infer page_info path. Please specify page_info_path.\"\n                    ) from e\n            else:\n                page_info: Any = response\n                for key in page_info_path:\n                    page_info = page_info[key]\n\n            if not page_info.get(\"hasNextPage\"):\n                break\n\n            after = page_info.get(\"endCursor\")\n\n        logger.info(f\"Fetched {len(collected)} records from {url}.\")\n        return collected\n</code></pre>"},{"location":"api/#civic_lib_core.graphql_utils.fetch_paginated","title":"fetch_paginated  <code>async</code>","text":"<pre><code>fetch_paginated(client: Any, query: Any, data_key: str, variables: Mapping[str, Any] | None = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Fetch all paginated results from a GraphQL query using cursor-based pagination.</p> <p>This function automatically handles pagination by making multiple requests to fetch all available data, using the standard GraphQL cursor-based pagination pattern with 'first', 'after', 'edges', 'pageInfo', 'hasNextPage', and 'endCursor' fields.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>The GraphQL client instance that supports async execution.</p> required <code>query</code> <code>Any</code> <p>The GraphQL query object to execute.</p> required <code>data_key</code> <code>str</code> <p>The key in the response data that contains the paginated results.</p> required <code>variables</code> <code>Mapping[str, Any] | None</code> <p>Additional variables to pass with the query. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list containing all the 'node' objects from all pages of results combined.</p> Example <pre><code>query = gql(\"query { users(first: $first, after: $after) { ... } }\")\nusers = await fetch_paginated(client, query, \"users\", {\"status\": \"active\"})\n</code></pre> Note <ul> <li>Uses a fixed page size of 100 items per request</li> <li>Automatically extracts 'node' objects from GraphQL 'edges'</li> <li>Logs the total number of records fetched upon completion</li> </ul> Source code in <code>src/civic_lib_core/graphql_utils.py</code> <pre><code>async def fetch_paginated(\n    client: Any,\n    query: Any,\n    data_key: str,\n    variables: Mapping[str, Any] | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetch all paginated results from a GraphQL query using cursor-based pagination.\n\n    This function automatically handles pagination by making multiple requests to fetch\n    all available data, using the standard GraphQL cursor-based pagination pattern with\n    'first', 'after', 'edges', 'pageInfo', 'hasNextPage', and 'endCursor' fields.\n\n    Args:\n        client (Any): The GraphQL client instance that supports async execution.\n        query (Any): The GraphQL query object to execute.\n        data_key (str): The key in the response data that contains the paginated results.\n        variables (Mapping[str, Any] | None, optional): Additional variables to pass\n            with the query. Defaults to None.\n\n    Returns:\n        list[dict[str, Any]]: A list containing all the 'node' objects from all pages\n            of results combined.\n\n    Example:\n        ```python\n        query = gql(\"query { users(first: $first, after: $after) { ... } }\")\n        users = await fetch_paginated(client, query, \"users\", {\"status\": \"active\"})\n        ```\n\n    Note:\n        - Uses a fixed page size of 100 items per request\n        - Automatically extracts 'node' objects from GraphQL 'edges'\n        - Logs the total number of records fetched upon completion\n    \"\"\"\n    all_results: list[dict[str, Any]] = []\n    after = None\n\n    while True:\n        page_vars = dict(variables) if variables else {}\n        page_vars.update({\"first\": 100, \"after\": after})\n\n        response = await client.execute_async(query, variable_values=page_vars)\n        page = response[data_key]\n        edges = page.get(\"edges\", [])\n\n        all_results.extend(edge[\"node\"] for edge in edges)\n\n        if not page.get(\"pageInfo\", {}).get(\"hasNextPage\"):\n            break\n\n        after = page[\"pageInfo\"].get(\"endCursor\")\n\n    logger.info(f\"Fetched {len(all_results)} total records for '{data_key}'.\")\n    return all_results\n</code></pre>"},{"location":"api/#civic_lib_core.graphql_utils.handle_transport_errors","title":"handle_transport_errors","text":"<pre><code>handle_transport_errors(e: Exception, resource_name: str = 'resource') -&gt; str\n</code></pre> <p>Handle GraphQL transport errors with appropriate logging and re-raising.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>Exception</code> <p>The exception to handle, typically a GraphQL transport error.</p> required <code>resource_name</code> <code>str</code> <p>Name of the resource being accessed for logging context. Defaults to \"resource\".</p> <code>'resource'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Error message for 403 Forbidden errors, indicating access not granted.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Re-raises the original exception after logging the appropriate error message based on the exception type.</p> Source code in <code>src/civic_lib_core/graphql_utils.py</code> <pre><code>def handle_transport_errors(e: Exception, resource_name: str = \"resource\") -&gt; str:\n    \"\"\"Handle GraphQL transport errors with appropriate logging and re-raising.\n\n    Args:\n        e (Exception): The exception to handle, typically a GraphQL transport error.\n        resource_name (str, optional): Name of the resource being accessed for\n            logging context. Defaults to \"resource\".\n\n    Returns:\n        str: Error message for 403 Forbidden errors, indicating access not granted.\n\n    Raises:\n        Exception: Re-raises the original exception after logging the appropriate\n            error message based on the exception type.\n    \"\"\"\n    if isinstance(e, TransportServerError):\n        if \"403\" in str(e):\n            logger.warning(f\"{resource_name} access not yet enabled (403 Forbidden).\")\n            return f\"{resource_name} access not yet granted\"\n        logger.error(f\"Server error while accessing {resource_name}: {e}\")\n\n    elif isinstance(e, TransportQueryError):\n        logger.error(f\"GraphQL query error while accessing {resource_name}: {e}\")\n\n    elif isinstance(e, TransportProtocolError):\n        logger.error(f\"Transport protocol error during {resource_name} query: {e}\")\n\n    else:\n        logger.error(f\"Unexpected error during {resource_name} query: {e}\")\n\n    raise e\n</code></pre>"},{"location":"api/#civic_lib_core.graphql_utils.paged_query","title":"paged_query","text":"<pre><code>paged_query(url: str, api_key: str, query: Any, data_path: Sequence[str]) -&gt; list[dict[str, Any]]\n</code></pre> <p>Execute a paginated GraphQL query synchronously and fetch all results.</p> <p>This is a synchronous wrapper around async_paged_query that uses asyncio.run to execute the asynchronous query in a blocking manner.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GraphQL endpoint URL.</p> required <code>api_key</code> <code>str</code> <p>Bearer token for API authentication.</p> required <code>query</code> <code>Any</code> <p>The GraphQL query object to execute.</p> required <code>data_path</code> <code>Sequence[str]</code> <p>Path to the data array in the response.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of all records collected from all pages, or empty list if an error occurs.</p> Source code in <code>src/civic_lib_core/graphql_utils.py</code> <pre><code>def paged_query(\n    url: str,\n    api_key: str,\n    query: Any,\n    data_path: Sequence[str],\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute a paginated GraphQL query synchronously and fetch all results.\n\n    This is a synchronous wrapper around async_paged_query that uses asyncio.run\n    to execute the asynchronous query in a blocking manner.\n\n    Args:\n        url (str): The GraphQL endpoint URL.\n        api_key (str): Bearer token for API authentication.\n        query (Any): The GraphQL query object to execute.\n        data_path (Sequence[str]): Path to the data array in the response.\n\n    Returns:\n        list[dict[str, Any]]: List of all records collected from all pages,\n            or empty list if an error occurs.\n    \"\"\"\n    try:\n        return asyncio.run(async_paged_query(url, api_key, query, data_path))\n    except Exception as e:\n        handle_transport_errors(e, resource_name=url)\n        return []\n</code></pre>"},{"location":"api/#civic_lib_core.log_utils","title":"log_utils","text":"<p>civic_lib_core/log_utils.py.</p> <p>Centralized logging for Civic Interconnect agents and libraries.</p>"},{"location":"api/#civic_lib_core.log_utils.init_logger","title":"init_logger","text":"<pre><code>init_logger(log_level: str | None = None, log_to_console: bool = True) -&gt; None\n</code></pre> <p>Initialize Loguru logging once per session.</p> <p>Loads config from project_policy.yaml if available.</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>Optional[str]</code> <p>Override log level (e.g. \"DEBUG\").</p> <code>None</code> <code>log_to_console</code> <code>bool</code> <p>Whether to also log to stderr.</p> <code>True</code> Source code in <code>src/civic_lib_core/log_utils.py</code> <pre><code>def init_logger(log_level: str | None = None, log_to_console: bool = True) -&gt; None:\n    \"\"\"Initialize Loguru logging once per session.\n\n    Loads config from project_policy.yaml if available.\n\n    Args:\n        log_level (Optional[str]): Override log level (e.g. \"DEBUG\").\n        log_to_console (bool): Whether to also log to stderr.\n    \"\"\"\n    global _logger_initialized\n    if _logger_initialized:\n        logger.debug(\"Logger already initialized.\")  # type: ignore[attr-defined]\n        return\n\n    # Remove default handlers\n    logger.remove()  # type: ignore[attr-defined]\n\n    layout = fs_utils.discover_project_layout()\n    project_root = layout.project_root\n\n    try:\n        policy = project_policy.load_project_policy(project_root)\n    except Exception as e:\n        policy = {}\n        logger.warning(f\"Failed to load project policy: {e}\")  # type: ignore[attr-defined]\n\n    log_subdir = policy.get(\"log_subdir\", \"logs\")\n    log_file_template = policy.get(\"log_file_template\", \"{time:YYYY-MM-DD}.log\")\n    retention_days = policy.get(\"log_retention_days\", 7)\n\n    logs_dir = project_root / log_subdir\n    fs_utils.ensure_dir(logs_dir)\n\n    log_file_path = logs_dir / log_file_template\n\n    try:\n        runtime_config_path = fs_utils.get_runtime_config_path(project_root)\n        if runtime_config_path.exists():\n            import yaml  # type: ignore\n\n            runtime_cfg = yaml.safe_load(runtime_config_path.read_text())\n            runtime_log_level = runtime_cfg.get(\"log_level\")\n        else:\n            runtime_log_level = None\n    except Exception as e:\n        logger.warning(f\"Failed to load runtime config: {e}\")\n        runtime_log_level = None\n\n    level = (log_level or runtime_log_level or policy.get(\"log_level\", \"INFO\")).upper().strip()\n\n    # Add file sink with structured format\n    logger.add(\n        str(log_file_path),\n        format=\"{time} | {level} | {message}\",\n        rotation=\"1 day\",\n        retention=f\"{retention_days} days\",\n        encoding=\"utf-8\",\n        level=level,\n        backtrace=True,\n        diagnose=True,\n    )\n\n    if log_to_console:\n        logger.add(\n            sink=sys.stderr,\n            format=\"&lt;green&gt;{time}&lt;/green&gt; | &lt;level&gt;{level}&lt;/level&gt; | {message}\",\n            level=level,\n            backtrace=True,\n            diagnose=True,\n        )\n\n    logger.info(f\"===== Civic Interconnect logger initialized (level: {level}) =====\")\n    _logger_initialized = True\n</code></pre>"},{"location":"api/#civic_lib_core.log_utils.log_agent_end","title":"log_agent_end","text":"<pre><code>log_agent_end(agent_name: str, status: str = 'success') -&gt; None\n</code></pre> <p>Log the end of an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Name of the agent.</p> required <code>status</code> <code>str</code> <p>Status text (e.g. \"success\" or \"error\").</p> <code>'success'</code> Source code in <code>src/civic_lib_core/log_utils.py</code> <pre><code>def log_agent_end(agent_name: str, status: str = \"success\") -&gt; None:\n    \"\"\"Log the end of an agent.\n\n    Args:\n        agent_name (str): Name of the agent.\n        status (str): Status text (e.g. \"success\" or \"error\").\n    \"\"\"\n    timestamp = now_utc_str()\n    logger.info(f\"===== {agent_name} completed with status: {status} at {timestamp} =====\")\n</code></pre>"},{"location":"api/#civic_lib_core.log_utils.log_agent_start","title":"log_agent_start","text":"<pre><code>log_agent_start(agent_name: str) -&gt; None\n</code></pre> <p>Log the start of an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Name of the agent.</p> required Source code in <code>src/civic_lib_core/log_utils.py</code> <pre><code>def log_agent_start(agent_name: str) -&gt; None:\n    \"\"\"Log the start of an agent.\n\n    Args:\n        agent_name (str): Name of the agent.\n    \"\"\"\n    logger.info(f\"===== Starting {agent_name} =====\")\n</code></pre>"},{"location":"api/#civic_lib_core.path_utils","title":"path_utils","text":"<p>Path utilities.</p> <p>File: civic_lib_core/path_utils.py</p>"},{"location":"api/#civic_lib_core.policy_utils","title":"policy_utils","text":"<p>Policy enforcement utilities for Civic Interconnect projects.</p>"},{"location":"api/#civic_lib_core.policy_utils.check_policy","title":"check_policy","text":"<pre><code>check_policy(repo_root: Path, repo_type: str) -&gt; list[str]\n</code></pre> <p>Check the project at repo_root against policy for the given repo_type.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of issues (empty list = all good)</p> Source code in <code>src/civic_lib_core/policy_utils.py</code> <pre><code>def check_policy(repo_root: Path, repo_type: str) -&gt; list[str]:\n    \"\"\"Check the project at repo_root against policy for the given repo_type.\n\n    Returns:\n        List of issues (empty list = all good)\n    \"\"\"\n    policy = project_policy.load_project_policy(repo_root)\n\n    issues = []\n\n    # Check required files for all repos\n    issues.extend(project_checks.check_required_files(repo_root, policy))\n\n    if repo_type == \"python\":\n        issues.extend(project_checks.check_python_project_files(repo_root, policy))\n        issues.extend(project_checks.check_python_project_dirs(repo_root, policy))\n        layout = _safe_discover_layout(repo_root)\n        if layout and layout.src_dir:\n            issues.extend(\n                project_checks.check_oversized_py_files(repo_root, layout.src_dir, policy)\n            )\n            issues.extend(project_checks.check_py_files_outside_src(repo_root, layout.src_dir))\n        else:\n            issues.append(\"No src/ directory found; skipping Python file checks.\")\n\n    if repo_type == \"node\":\n        issues.extend(\n            project_checks.check_additional_files(repo_root, policy, \"node_project_files\")\n        )\n\n    if repo_type == \"pwa\":\n        issues.extend(project_checks.check_additional_files(repo_root, policy, \"pwa_project_files\"))\n\n    # Check for empty directories\n    issues.extend(project_checks.check_empty_dirs(repo_root))\n\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks","title":"project_checks","text":"<p>civic_lib_core/project_checks.py.</p> <p>Run structural and policy checks on a Civic Interconnect project.</p>"},{"location":"api/#civic_lib_core.project_checks.check_additional_files","title":"check_additional_files","text":"<pre><code>check_additional_files(project_root: Path, policy: dict, key: str) -&gt; list[str]\n</code></pre> <p>Check additional file requirements from project policy.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>policy</code> <code>dict</code> <p>Project policy.</p> required <code>key</code> <code>str</code> <p>Policy key like 'node_project_files' or 'pwa_project_files'.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for missing files.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_additional_files(project_root: Path, policy: dict, key: str) -&gt; list[str]:\n    \"\"\"Check additional file requirements from project policy.\n\n    Args:\n        project_root (Path): Project root.\n        policy (dict): Project policy.\n        key (str): Policy key like 'node_project_files' or 'pwa_project_files'.\n\n    Returns:\n        list[str]: Issues for missing files.\n    \"\"\"\n    issues = []\n    required = policy.get(key, [])\n    for filename in required:\n        if not (project_root / filename).exists():\n            issues.append(f\"Missing {key.replace('_', ' ')} file: {filename}\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_empty_dirs","title":"check_empty_dirs","text":"<pre><code>check_empty_dirs(project_root: Path) -&gt; list[str]\n</code></pre> <p>Find empty directories in the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Root of the project.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for empty directories.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_empty_dirs(project_root: Path) -&gt; list[str]:\n    \"\"\"Find empty directories in the project.\n\n    Args:\n        project_root (Path): Root of the project.\n\n    Returns:\n        list[str]: Issues for empty directories.\n    \"\"\"\n    issues = []\n    for path in project_root.rglob(\"*\"):\n        if path.is_dir() and not any(path.iterdir()):\n            issues.append(f\"Empty directory found: {path.relative_to(project_root)}\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_oversized_py_files","title":"check_oversized_py_files","text":"<pre><code>check_oversized_py_files(project_root: Path, src_dir: Path, policy: dict) -&gt; list[str]\n</code></pre> <p>Check for Python files exceeding allowed line limits.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>src_dir</code> <code>Path</code> <p>Source directory.</p> required <code>policy</code> <code>dict</code> <p>Project policy.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for oversized files.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_oversized_py_files(project_root: Path, src_dir: Path, policy: dict) -&gt; list[str]:\n    \"\"\"Check for Python files exceeding allowed line limits.\n\n    Args:\n        project_root (Path): Project root.\n        src_dir (Path): Source directory.\n        policy (dict): Project policy.\n\n    Returns:\n        list[str]: Issues for oversized files.\n    \"\"\"\n    issues = []\n    max_py_length = policy.get(\"max_python_file_length\", 1000)\n\n    for py_file in src_dir.rglob(\"*.py\"):\n        try:\n            lines = py_file.read_text(encoding=\"utf-8\", errors=\"ignore\").splitlines()\n            if len(lines) &gt; max_py_length:\n                issues.append(\n                    f\"Python file too long ({len(lines)} lines): {py_file.relative_to(project_root)}\"\n                )\n        except Exception as e:\n            issues.append(f\"Could not read file {py_file}: {e}\")\n\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_py_files_outside_src","title":"check_py_files_outside_src","text":"<pre><code>check_py_files_outside_src(project_root: Path, src_dir: Path) -&gt; list[str]\n</code></pre> <p>Check for .py files outside src_dir, ignoring top-level scripts.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>src_dir</code> <code>Path</code> <p>Source directory.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for files outside src.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_py_files_outside_src(project_root: Path, src_dir: Path) -&gt; list[str]:\n    \"\"\"Check for .py files outside src_dir, ignoring top-level scripts.\n\n    Args:\n        project_root (Path): Project root.\n        src_dir (Path): Source directory.\n\n    Returns:\n        list[str]: Issues for files outside src.\n    \"\"\"\n    issues = []\n    for py_file in project_root.rglob(\"*.py\"):\n        if src_dir in py_file.parents:\n            continue\n        # Ignore top-level scripts in the repo root\n        if py_file.parent == project_root:\n            continue\n        issues.append(f\"Python file outside src/ directory: {py_file.relative_to(project_root)}\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_python_project_dirs","title":"check_python_project_dirs","text":"<pre><code>check_python_project_dirs(project_root: Path, policy: dict) -&gt; list[str]\n</code></pre> <p>Check required directories for Python projects.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>policy</code> <code>dict</code> <p>Project policy.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for missing dirs.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_python_project_dirs(project_root: Path, policy: dict) -&gt; list[str]:\n    \"\"\"Check required directories for Python projects.\n\n    Args:\n        project_root (Path): Project root.\n        policy (dict): Project policy.\n\n    Returns:\n        list[str]: Issues for missing dirs.\n    \"\"\"\n    issues = []\n    for dirname in policy.get(\"python_project_dirs\", []):\n        if not (project_root / dirname).exists():\n            issues.append(f\"Missing Python project directory: {dirname}/\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_python_project_files","title":"check_python_project_files","text":"<pre><code>check_python_project_files(project_root: Path, policy: dict) -&gt; list[str]\n</code></pre> <p>Check required files for Python projects.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>policy</code> <code>dict</code> <p>Project policy.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for missing files.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_python_project_files(project_root: Path, policy: dict) -&gt; list[str]:\n    \"\"\"Check required files for Python projects.\n\n    Args:\n        project_root (Path): Project root.\n        policy (dict): Project policy.\n\n    Returns:\n        list[str]: Issues for missing files.\n    \"\"\"\n    issues = []\n    for filename in policy.get(\"python_project_files\", []):\n        if not (project_root / filename).exists():\n            issues.append(f\"Missing Python project file: {filename}\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.check_required_files","title":"check_required_files","text":"<pre><code>check_required_files(project_root: Path, policy: dict) -&gt; list[str]\n</code></pre> <p>Check files required in all Civic Interconnect repos.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path</code> <p>Project root.</p> required <code>policy</code> <code>dict</code> <p>Project policy.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Issues for missing required files.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def check_required_files(project_root: Path, policy: dict) -&gt; list[str]:\n    \"\"\"Check files required in all Civic Interconnect repos.\n\n    Args:\n        project_root (Path): Project root.\n        policy (dict): Project policy.\n\n    Returns:\n        list[str]: Issues for missing required files.\n    \"\"\"\n    issues = []\n    for filename in policy.get(\"required_files\", []):\n        if not (project_root / filename).exists():\n            issues.append(f\"Missing required file: {filename}\")\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Run all checks from CLI entry point.</p> <p>Prints results and exits with appropriate code.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Run all checks from CLI entry point.\n\n    Prints results and exits with appropriate code.\n    \"\"\"\n    import sys\n\n    issues = run_all_checks()\n    if issues:\n        print(\"Project checks found the following issues:\\n\")\n        for issue in issues:\n            print(f\"- {issue}\")\n        sys.exit(1)\n    else:\n        print(\"All project checks passed successfully.\")\n        sys.exit(0)\n</code></pre>"},{"location":"api/#civic_lib_core.project_checks.run_all_checks","title":"run_all_checks","text":"<pre><code>run_all_checks() -&gt; list[str]\n</code></pre> <p>Run all project-level checks.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of issues found.</p> Source code in <code>src/civic_lib_core/project_checks.py</code> <pre><code>def run_all_checks() -&gt; list[str]:\n    \"\"\"Run all project-level checks.\n\n    Returns:\n        list[str]: List of issues found.\n    \"\"\"\n    issues = []\n\n    project_root = fs_utils.get_project_root()\n    policy = project_policy.load_project_policy(project_root)\n    layout = fs_utils.discover_project_layout()\n    src_dir = getattr(layout, \"src_dir\", None)\n\n    issues.extend(check_required_files(project_root, policy))\n\n    # Check Python-specific files\n    if isinstance(src_dir, Path):\n        issues.extend(check_python_project_files(project_root, policy))\n        issues.extend(check_python_project_dirs(project_root, policy))\n        issues.extend(check_oversized_py_files(project_root, src_dir, policy))\n        issues.extend(check_py_files_outside_src(project_root, src_dir))\n    else:\n        issues.append(\"No source directory found. Skipping Python file checks.\")\n\n    # Check Node.js files if applicable\n    issues.extend(check_additional_files(project_root, policy, key=\"node_project_files\"))\n\n    # Check PWA files if applicable\n    issues.extend(check_additional_files(project_root, policy, key=\"pwa_project_files\"))\n\n    issues.extend(check_empty_dirs(project_root))\n\n    return issues\n</code></pre>"},{"location":"api/#civic_lib_core.project_layout","title":"project_layout","text":"<p>civic_lib_core/project_layout.py.</p> <p>Discover and verify basic project layout for any Civic Interconnect client repo.</p>"},{"location":"api/#civic_lib_core.project_layout.ProjectLayout","title":"ProjectLayout","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Represents the layout of a Civic Interconnect project.</p> <p>Attributes:</p> Name Type Description <code>project_root</code> <code>Path</code> <p>Root directory of the project.</p> <code>src_dir</code> <code>Path | None</code> <p>Source directory, or None if not found.</p> <code>docs_dir</code> <code>Path | None</code> <p>Documentation directory, or None if not found.</p> <code>docs_api_dir</code> <code>Path | None</code> <p>API documentation source directory, or None if not found.</p> <code>packages</code> <code>list[Path]</code> <p>List of package directories under src_dir.</p> <code>org_name</code> <code>str | None</code> <p>Organization name, if detected.</p> <code>policy</code> <code>dict</code> <p>Loaded project policy data.</p> Source code in <code>src/civic_lib_core/project_layout.py</code> <pre><code>class ProjectLayout(NamedTuple):\n    \"\"\"Represents the layout of a Civic Interconnect project.\n\n    Attributes:\n        project_root (Path): Root directory of the project.\n        src_dir (Path | None): Source directory, or None if not found.\n        docs_dir (Path | None): Documentation directory, or None if not found.\n        docs_api_dir (Path | None): API documentation source directory, or None if not found.\n        packages (list[Path]): List of package directories under src_dir.\n        org_name (str | None): Organization name, if detected.\n        policy (dict): Loaded project policy data.\n    \"\"\"\n\n    project_root: Path\n    src_dir: Path | None\n    docs_dir: Path | None\n    docs_api_dir: Path | None\n    packages: list[Path]\n    org_name: str | None\n    policy: dict\n</code></pre>"},{"location":"api/#civic_lib_core.project_layout.discover_project_layout","title":"discover_project_layout","text":"<pre><code>discover_project_layout() -&gt; ProjectLayout\n</code></pre> <p>Discover and return the layout of the current Civic Interconnect project.</p> <p>Delegates to <code>fs_utils.discover_project_layout()</code> to perform actual discovery.</p> <p>Returns:</p> Name Type Description <code>ProjectLayout</code> <code>ProjectLayout</code> <p>Populated project layout info.</p> Source code in <code>src/civic_lib_core/project_layout.py</code> <pre><code>def discover_project_layout() -&gt; ProjectLayout:\n    \"\"\"Discover and return the layout of the current Civic Interconnect project.\n\n    Delegates to `fs_utils.discover_project_layout()` to perform actual discovery.\n\n    Returns:\n        ProjectLayout: Populated project layout info.\n    \"\"\"\n    return fs_utils.discover_project_layout()\n</code></pre>"},{"location":"api/#civic_lib_core.project_layout.format_layout","title":"format_layout","text":"<pre><code>format_layout(layout: ProjectLayout) -&gt; str\n</code></pre> <p>Format the layout info for display.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>ProjectLayout</code> <p>The layout info to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted layout details.</p> Source code in <code>src/civic_lib_core/project_layout.py</code> <pre><code>def format_layout(layout: ProjectLayout) -&gt; str:\n    \"\"\"Format the layout info for display.\n\n    Args:\n        layout (ProjectLayout): The layout info to format.\n\n    Returns:\n        str: Formatted layout details.\n    \"\"\"\n    parts = [\n        f\"Org:      {layout.org_name or 'unknown'}\",\n        f\"Root:     {layout.project_root}\",\n        f\"API Docs: {layout.docs_api_dir or 'none'}\",\n        f\"Source:   {layout.src_dir or 'none'}\",\n        f\"Policy:   {layout.policy.get('__policy_path__', 'unknown')}\",\n        \"Packages:\",\n        *(\n            [f\"  - {p.relative_to(layout.project_root)}\" for p in layout.packages]\n            or [\"  (no packages found)\"]\n        ),\n    ]\n    return \"\\n\".join(parts)\n</code></pre>"},{"location":"api/#civic_lib_core.project_layout.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Standalone entry point for manual testing of this layout module.</p> <p>Prints layout and any issues found.</p> Source code in <code>src/civic_lib_core/project_layout.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Standalone entry point for manual testing of this layout module.\n\n    Prints layout and any issues found.\n    \"\"\"\n    import sys\n\n    try:\n        layout = discover_project_layout()\n        print(\"\\n\" + format_layout(layout) + \"\\n\")\n\n        issues = verify_layout(layout)\n        if issues:\n            print(\"\\nProblems found:\")\n            for issue in issues:\n                print(f\"- {issue}\")\n            sys.exit(1)\n        else:\n            print(\"\\nLayout verified successfully.\")\n            sys.exit(0)\n    except Exception as e:\n        print(\n            f\"\\nAn error occurred during project layout discovery/verification: {e}\",\n            file=sys.stderr,\n        )\n        sys.exit(1)\n</code></pre>"},{"location":"api/#civic_lib_core.project_layout.verify_layout","title":"verify_layout","text":"<pre><code>verify_layout(layout: ProjectLayout) -&gt; list[str]\n</code></pre> <p>Verify that the discovered layout satisfies expectations.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>ProjectLayout</code> <p>The layout to check.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of issues found (empty list means all OK).</p> Source code in <code>src/civic_lib_core/project_layout.py</code> <pre><code>def verify_layout(layout: ProjectLayout) -&gt; list[str]:\n    \"\"\"Verify that the discovered layout satisfies expectations.\n\n    Args:\n        layout (ProjectLayout): The layout to check.\n\n    Returns:\n        list[str]: List of issues found (empty list means all OK).\n    \"\"\"\n    errors: list[str] = []\n\n    if not layout.project_root.exists():\n        errors.append(f\"Project root not found: {layout.project_root}\")\n    elif not layout.project_root.is_dir():\n        errors.append(f\"Project root is not a directory: {layout.project_root}\")\n\n    if layout.src_dir:\n        if not layout.src_dir.exists():\n            errors.append(f\"Missing source directory: {layout.src_dir}\")\n        elif not layout.src_dir.is_dir():\n            errors.append(f\"Source directory is not a directory: {layout.src_dir}\")\n        elif not layout.packages:\n            errors.append(f\"No Python packages found under: {layout.src_dir}\")\n\n    if layout.docs_api_dir:\n        if not layout.docs_api_dir.exists():\n            errors.append(f\"Missing API docs source directory: {layout.docs_api_dir}\")\n        elif not layout.docs_api_dir.is_dir():\n            errors.append(f\"API docs source directory is not a directory: {layout.docs_api_dir}\")\n\n    return errors\n</code></pre>"},{"location":"api/#civic_lib_core.project_policy","title":"project_policy","text":"<p>civic_lib_core/project_policy.py.</p> <p>Load the project policy for any Civic Interconnect client repo.</p>"},{"location":"api/#civic_lib_core.project_policy.load_project_policy","title":"load_project_policy","text":"<pre><code>load_project_policy(project_root: Path | None = None, override_file: Path | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Load Civic Interconnect project policy.</p> <p>Behavior: - Load defaults from civic_lib_core's bundled <code>project_policy.yaml</code>. - If a client repo defines its own <code>project_policy.yaml</code>, merge its   overrides into the default policy.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>Path | None</code> <p>Optional project root to look for client <code>project_policy.yaml</code>.</p> <code>None</code> <code>override_file</code> <code>Path | None</code> <p>Optional path to explicitly provide a custom policy file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>Combined policy dictionary.</p> Source code in <code>src/civic_lib_core/project_policy.py</code> <pre><code>def load_project_policy(\n    project_root: Path | None = None,\n    override_file: Path | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Load Civic Interconnect project policy.\n\n    Behavior:\n    - Load defaults from civic_lib_core's bundled `project_policy.yaml`.\n    - If a client repo defines its own `project_policy.yaml`, merge its\n      overrides into the default policy.\n\n    Args:\n        project_root: Optional project root to look for client `project_policy.yaml`.\n        override_file: Optional path to explicitly provide a custom policy file.\n\n    Returns:\n        dict: Combined policy dictionary.\n    \"\"\"\n    # Load default policy\n    try:\n        with DEFAULT_POLICY_PATH.open(encoding=\"utf-8\") as f:\n            policy_data = yaml.safe_load(f) or {}\n    except FileNotFoundError:\n        logger.warning(f\"Default policy file not found at {DEFAULT_POLICY_PATH}\")\n        policy_data = {}\n    except yaml.YAMLError as e:\n        logger.error(f\"Failed to parse default policy file at {DEFAULT_POLICY_PATH}: {e}\")\n        raise\n\n    # Load client-specific override if provided\n    custom_policy_path = None\n\n    if override_file:\n        custom_policy_path = Path(override_file)\n    elif project_root:\n        custom_policy_path = Path(project_root) / \"project_policy.yaml\"\n\n    if custom_policy_path and custom_policy_path.exists():\n        try:\n            with custom_policy_path.open(encoding=\"utf-8\") as f:\n                custom_data = yaml.safe_load(f) or {}\n\n            policy_data = _deep_merge_dicts(policy_data, custom_data)\n            policy_data[\"__policy_path__\"] = str(custom_policy_path)\n\n            logger.debug(f\"Loaded custom policy from {custom_policy_path}\")\n\n        except yaml.YAMLError as e:\n            logger.error(f\"Failed to parse custom policy at {custom_policy_path}: {e}\")\n            raise\n\n    # Indicate the policy file used\n    if \"__policy_path__\" not in policy_data:\n        policy_data[\"__policy_path__\"] = str(DEFAULT_POLICY_PATH)\n\n    return policy_data\n</code></pre>"},{"location":"api/#civic_lib_core.report_archiver","title":"report_archiver","text":"<p>civic_lib_core/report_archiver.py.</p> <p>Archives old Civic Interconnect agent reports by renaming them with <code>.archived.json</code>. Used by admin and maintenance tools, not daily agents.</p>"},{"location":"api/#civic_lib_core.report_archiver.archive_old_reports","title":"archive_old_reports","text":"<pre><code>archive_old_reports(agent_dir: Path, keep_latest: bool = True) -&gt; list[Path]\n</code></pre> <p>Rename old .json reports to .archived.json, optionally keeping the latest.</p> <p>Parameters:</p> Name Type Description Default <code>agent_dir</code> <code>Path</code> <p>Directory with report files.</p> required <code>keep_latest</code> <code>bool</code> <p>Whether to keep the most recent report unarchived.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: List of archived report file paths.</p> Source code in <code>src/civic_lib_core/report_archiver.py</code> <pre><code>def archive_old_reports(agent_dir: Path, keep_latest: bool = True) -&gt; list[Path]:\n    \"\"\"Rename old .json reports to .archived.json, optionally keeping the latest.\n\n    Args:\n        agent_dir (Path): Directory with report files.\n        keep_latest (bool): Whether to keep the most recent report unarchived.\n\n    Returns:\n        list[Path]: List of archived report file paths.\n    \"\"\"\n    if not agent_dir.exists() or not agent_dir.is_dir():\n        logger.warning(f\"Agent report directory does not exist: {agent_dir}\")\n        return []\n\n    json_reports = sorted(agent_dir.glob(\"*.json\"), reverse=True)\n\n    if keep_latest and json_reports:\n        json_reports = json_reports[1:]  # Skip most recent\n\n    archived = []\n\n    for path in json_reports:\n        # Safer alternative if you want to preserve complex suffixes:\n        # archived_path = path.with_name(path.stem + \".archived.json\")\n        archived_path = path.with_suffix(\".archived.json\")\n        try:\n            path.rename(archived_path)\n            logger.info(f\"Archived report: {archived_path}\")\n            archived.append(archived_path)\n        except Exception as e:\n            logger.error(f\"Failed to archive {path}: {e}\")\n            # raise e  # Uncomment if you want failures to crash the script\n\n    return archived\n</code></pre>"},{"location":"api/#civic_lib_core.report_archiver.archive_reports_older_than","title":"archive_reports_older_than","text":"<pre><code>archive_reports_older_than(agent_dir: Path, days_old: int) -&gt; list[Path]\n</code></pre> <p>Archive reports older than a specified number of days.</p> <p>Parameters:</p> Name Type Description Default <code>agent_dir</code> <code>Path</code> <p>Directory with report files.</p> required <code>days_old</code> <code>int</code> <p>Number of days to retain. Older reports get archived.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: List of archived report file paths.</p> Source code in <code>src/civic_lib_core/report_archiver.py</code> <pre><code>def archive_reports_older_than(agent_dir: Path, days_old: int) -&gt; list[Path]:\n    \"\"\"Archive reports older than a specified number of days.\n\n    Args:\n        agent_dir (Path): Directory with report files.\n        days_old (int): Number of days to retain. Older reports get archived.\n\n    Returns:\n        list[Path]: List of archived report file paths.\n    \"\"\"\n    cutoff_date = datetime.now(UTC) - timedelta(days=days_old)\n    archived = []\n\n    for path in agent_dir.glob(\"*.json\"):\n        try:\n            date_str = path.stem\n            report_date = datetime.strptime(date_str, DATE_ONLY_FORMAT).replace(tzinfo=UTC)\n            if report_date &lt; cutoff_date:\n                archived_path = path.with_suffix(\".archived.json\")\n                path.rename(archived_path)\n                logger.info(f\"Archived report older than {days_old} days: {archived_path}\")\n                archived.append(archived_path)\n        except ValueError:\n            logger.warning(f\"Skipping non-date report file: {path.name}\")\n        except Exception as e:\n            logger.error(f\"Failed to archive {path.name}: {e}\")\n            # raise e\n\n    return archived\n</code></pre>"},{"location":"api/#civic_lib_core.report_constants","title":"report_constants","text":"<p>civic_lib_core/report_constants.py.</p> <p>Shared constants for report generation, reading, validation, and indexing. Used across Civic Interconnect agents and admin tools.</p>"},{"location":"api/#civic_lib_core.report_formatter","title":"report_formatter","text":"<p>civic_lib_core/report_formatter.py.</p> <p>Format Civic Interconnect agent reports into various human-readable forms. Supports Markdown, plain text, and CSV formats.</p>"},{"location":"api/#civic_lib_core.report_formatter.format_report_as_csv","title":"format_report_as_csv","text":"<pre><code>format_report_as_csv(report: dict[str, Any]) -&gt; str\n</code></pre> <p>Format a report dictionary as a CSV string.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>dict</code> <p>A dictionary containing report data with a 'results' key           that holds a list of dictionaries to be formatted as CSV.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A CSV-formatted string with headers and data rows, or a message  indicating no results are available if the results list is empty.</p> Source code in <code>src/civic_lib_core/report_formatter.py</code> <pre><code>def format_report_as_csv(report: dict[str, Any]) -&gt; str:\n    \"\"\"Format a report dictionary as a CSV string.\n\n    Args:\n        report (dict): A dictionary containing report data with a 'results' key\n                      that holds a list of dictionaries to be formatted as CSV.\n\n    Returns:\n        str: A CSV-formatted string with headers and data rows, or a message\n             indicating no results are available if the results list is empty.\n    \"\"\"\n    results = report.get(\"results\", [])\n    if not results:\n        return \"No results to export.\"\n\n    output = io.StringIO()\n    writer = csv.DictWriter(output, fieldnames=results[0].keys())\n    writer.writeheader()\n    writer.writerows(results)\n    return output.getvalue()\n</code></pre>"},{"location":"api/#civic_lib_core.report_formatter.format_report_as_markdown","title":"format_report_as_markdown","text":"<pre><code>format_report_as_markdown(report: dict[str, Any]) -&gt; str\n</code></pre> <p>Format a report dictionary as a markdown string.</p> <p>Takes a report dictionary containing agent information, metadata, and results, and converts it into a well-formatted markdown document with a summary section and a sample result displayed as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>dict[str, Any]</code> <p>A dictionary containing report data with the following optional keys: - 'agent': Name of the agent that generated the report - 'timestamp': When the report was generated - 'agent_version': Version of the agent - 'lib_version': Version of the library used - 'record_count': Number of records processed - 'results': List of result objects</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A markdown-formatted string containing the report summary and  the first result from the results list (if available) displayed  as a JSON code block.</p> Example <p>report = { ...     'agent': 'DataProcessor', ...     'timestamp': '2023-10-01T12:00:00Z', ...     'record_count': 100, ...     'results': [{'id': 1, 'status': 'success'}], ... } markdown = format_report_as_markdown(report) print(markdown)</p> Source code in <code>src/civic_lib_core/report_formatter.py</code> <pre><code>def format_report_as_markdown(report: dict[str, Any]) -&gt; str:\n    \"\"\"Format a report dictionary as a markdown string.\n\n    Takes a report dictionary containing agent information, metadata, and results,\n    and converts it into a well-formatted markdown document with a summary section\n    and a sample result displayed as JSON.\n\n    Args:\n        report (dict[str, Any]): A dictionary containing report data with the following\n            optional keys:\n            - 'agent': Name of the agent that generated the report\n            - 'timestamp': When the report was generated\n            - 'agent_version': Version of the agent\n            - 'lib_version': Version of the library used\n            - 'record_count': Number of records processed\n            - 'results': List of result objects\n\n    Returns:\n        str: A markdown-formatted string containing the report summary and\n             the first result from the results list (if available) displayed\n             as a JSON code block.\n\n    Example:\n        &gt;&gt;&gt; report = {\n        ...     'agent': 'DataProcessor',\n        ...     'timestamp': '2023-10-01T12:00:00Z',\n        ...     'record_count': 100,\n        ...     'results': [{'id': 1, 'status': 'success'}],\n        ... }\n        &gt;&gt;&gt; markdown = format_report_as_markdown(report)\n        &gt;&gt;&gt; print(markdown)\n        # Report Summary for DataProcessor\n        **Date:** 2023-10-01T12:00:00Z\n        ...\n    \"\"\"\n    lines = [\n        f\"# Report Summary for {report.get('agent', 'Unknown Agent')}\",\n        f\"**Date:** {report.get('timestamp', 'Unknown')}\",\n        f\"**Agent Version:** {report.get('agent_version', 'N/A')}\",\n        f\"**Library Version:** {report.get('lib_version', 'N/A')}\",\n        f\"**Record Count:** {report.get('record_count', 'N/A')}\",\n        \"\",\n        \"## Sample Result\",\n    ]\n    sample = report.get(\"results\", [])\n    if sample:\n        lines.append(\"```json\")\n        lines.append(json.dumps(sample[0], indent=2))\n        lines.append(\"```\")\n    else:\n        lines.append(\"_No results to display._\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#civic_lib_core.report_formatter.format_report_as_markdown--report-summary-for-dataprocessor","title":"Report Summary for DataProcessor","text":"<p>Date: 2023-10-01T12:00:00Z ...</p>"},{"location":"api/#civic_lib_core.report_formatter.format_report_as_text","title":"format_report_as_text","text":"<pre><code>format_report_as_text(report: dict[str, Any]) -&gt; str\n</code></pre> <p>Format a report dictionary as a human-readable text string.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>dict</code> <p>A dictionary containing report data with keys like 'agent',           'timestamp', 'agent_version', 'lib_version', 'record_count',           and 'results'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted multi-line string representation of the report including  metadata and the first sample result (if available).</p> Example <p>report = { ...     'agent': 'DataCollector', ...     'timestamp': '2023-10-15 14:30:00', ...     'agent_version': '1.2.3', ...     'lib_version': '2.1.0', ...     'record_count': 150, ...     'results': [{'id': 1, 'value': 'sample'}], ... } print(format_report_as_text(report)) Report: DataCollector Date: 2023-10-15 14:30:00 Agent Version: 1.2.3 Library Version: 2.1.0 Record Count: 150</p> <p>Sample Result: {   \"id\": 1,   \"value\": \"sample\" }</p> Source code in <code>src/civic_lib_core/report_formatter.py</code> <pre><code>def format_report_as_text(report: dict[str, Any]) -&gt; str:\n    \"\"\"Format a report dictionary as a human-readable text string.\n\n    Args:\n        report (dict): A dictionary containing report data with keys like 'agent',\n                      'timestamp', 'agent_version', 'lib_version', 'record_count',\n                      and 'results'.\n\n    Returns:\n        str: A formatted multi-line string representation of the report including\n             metadata and the first sample result (if available).\n\n    Example:\n        &gt;&gt;&gt; report = {\n        ...     'agent': 'DataCollector',\n        ...     'timestamp': '2023-10-15 14:30:00',\n        ...     'agent_version': '1.2.3',\n        ...     'lib_version': '2.1.0',\n        ...     'record_count': 150,\n        ...     'results': [{'id': 1, 'value': 'sample'}],\n        ... }\n        &gt;&gt;&gt; print(format_report_as_text(report))\n        Report: DataCollector\n        Date: 2023-10-15 14:30:00\n        Agent Version: 1.2.3\n        Library Version: 2.1.0\n        Record Count: 150\n\n        Sample Result:\n        {\n          \"id\": 1,\n          \"value\": \"sample\"\n        }\n    \"\"\"\n    lines = [\n        f\"Report: {report.get('agent', 'Unknown Agent')}\",\n        f\"Date: {report.get('timestamp', 'Unknown')}\",\n        f\"Agent Version: {report.get('agent_version', 'N/A')}\",\n        f\"Library Version: {report.get('lib_version', 'N/A')}\",\n        f\"Record Count: {report.get('record_count', 'N/A')}\",\n        \"\",\n        \"Sample Result:\",\n    ]\n    sample = report.get(\"results\", [])\n    if sample:\n        lines.append(json.dumps(sample[0], indent=2))\n    else:\n        lines.append(\"No results to display.\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/#civic_lib_core.report_formatter.to_csv","title":"to_csv","text":"<pre><code>to_csv(data: list[dict[str, Any]], path: Path) -&gt; None\n</code></pre> <p>Write a list of dictionaries to a CSV file.</p> <p>If the data list is empty, writes \"No results to export.\" to the file instead. The CSV header is generated from the keys of the first dictionary in the list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[dict[str, Any]]</code> <p>A list of dictionaries to write to CSV. All dictionaries should   have the same keys for proper CSV formatting.</p> required <code>path</code> <code>Path</code> <p>The file path where the CSV will be written. Will be created   if it doesn't exist.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Note <p>The file is written with UTF-8 encoding. If data is empty, a plain text message is written instead of CSV format.</p> Source code in <code>src/civic_lib_core/report_formatter.py</code> <pre><code>def to_csv(data: list[dict[str, Any]], path: Path) -&gt; None:\n    \"\"\"Write a list of dictionaries to a CSV file.\n\n    If the data list is empty, writes \"No results to export.\" to the file instead.\n    The CSV header is generated from the keys of the first dictionary in the list.\n\n    Args:\n        data: A list of dictionaries to write to CSV. All dictionaries should\n              have the same keys for proper CSV formatting.\n        path: The file path where the CSV will be written. Will be created\n              if it doesn't exist.\n\n    Returns:\n        None\n\n    Note:\n        The file is written with UTF-8 encoding. If data is empty, a plain text\n        message is written instead of CSV format.\n    \"\"\"\n    if not data:\n        path.write_text(\"No results to export.\", encoding=\"utf-8\")\n        return\n\n    with path.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n        writer = csv.DictWriter(f, fieldnames=data[0].keys())\n        writer.writeheader()\n        writer.writerows(data)\n</code></pre>"},{"location":"api/#civic_lib_core.report_formatter.to_markdown","title":"to_markdown","text":"<pre><code>to_markdown(data: list[dict[str, Any]], path: Path) -&gt; None\n</code></pre> <p>Convert a list of dictionaries to a Markdown table and write it to a file.</p> <p>Takes a list of dictionaries where each dictionary represents a row of data, and converts it into a Markdown table format. The keys of the first dictionary are used as column headers. If the data list is empty, writes a message indicating no results to display.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[dict[str, Any]]</code> <p>List of dictionaries containing the data to convert.                        Each dictionary should have the same keys which will                        be used as table headers.</p> required <code>path</code> <code>Path</code> <p>Path object specifying where to write the Markdown table file.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function writes directly to the specified file path.</p> Note <ul> <li>Pipe characters (|) in data values are automatically escaped to preserve   Markdown table formatting.</li> <li>The file is written with UTF-8 encoding.</li> <li>If data is empty, writes \"No results to display.\" to the file.</li> </ul> Source code in <code>src/civic_lib_core/report_formatter.py</code> <pre><code>def to_markdown(data: list[dict[str, Any]], path: Path) -&gt; None:\n    \"\"\"Convert a list of dictionaries to a Markdown table and write it to a file.\n\n    Takes a list of dictionaries where each dictionary represents a row of data,\n    and converts it into a Markdown table format. The keys of the first dictionary\n    are used as column headers. If the data list is empty, writes a message\n    indicating no results to display.\n\n    Args:\n        data (list[dict[str, Any]]): List of dictionaries containing the data to convert.\n                                   Each dictionary should have the same keys which will\n                                   be used as table headers.\n        path (Path): Path object specifying where to write the Markdown table file.\n\n    Returns:\n        None: The function writes directly to the specified file path.\n\n    Note:\n        - Pipe characters (|) in data values are automatically escaped to preserve\n          Markdown table formatting.\n        - The file is written with UTF-8 encoding.\n        - If data is empty, writes \"_No results to display._\" to the file.\n    \"\"\"\n    if not data:\n        path.write_text(\"_No results to display._\", encoding=\"utf-8\")\n        return\n\n    headers = list(data[0].keys())\n    lines = [\"| \" + \" | \".join(headers) + \" |\"]\n    lines.append(\"|\" + \"|\".join([\"---\"] * len(headers)) + \"|\")\n\n    for row in data:\n        # Escape any pipe characters to preserve Markdown table\n        row_values = [str(row[h]).replace(\"|\", \"\\\\|\") for h in headers]\n        lines.append(\"| \" + \" | \".join(row_values) + \" |\")\n\n    path.write_text(\"\\n\".join(lines), encoding=\"utf-8\")\n</code></pre>"},{"location":"api/#civic_lib_core.report_indexer","title":"report_indexer","text":"<p>Module for generating a Markdown index of agent reports.</p> <p>This module provides: - generate_index: generates a Markdown index listing the latest report from each agent</p>"},{"location":"api/#civic_lib_core.report_indexer.generate_index","title":"generate_index","text":"<pre><code>generate_index(report_dir: Path = REPORTS_DIR) -&gt; None\n</code></pre> <p>Generate a Markdown index listing the latest report from each agent.</p> <p>Parameters:</p> Name Type Description Default <code>report_dir</code> <code>Path</code> <p>The base <code>reports/</code> directory to scan.</p> <code>REPORTS_DIR</code> Source code in <code>src/civic_lib_core/report_indexer.py</code> <pre><code>def generate_index(report_dir: Path = REPORTS_DIR) -&gt; None:\n    \"\"\"Generate a Markdown index listing the latest report from each agent.\n\n    Args:\n        report_dir (Path): The base `reports/` directory to scan.\n    \"\"\"\n    logger.info(\"Generating index of agent reports...\")\n\n    index_file = report_dir / \"index.md\"\n    ensure_dir(index_file.parent)\n\n    if index_file.exists():\n        logger.debug(f\"Removing old index file at {index_file}\")\n        index_file.unlink()\n\n    logger.debug(f\"Creating new index file at {index_file}\")\n    lines = [\"# Civic Interconnect Agent Reports\", \"\"]\n\n    for agent_dir in sorted(report_dir.iterdir(), key=lambda p: p.name.lower()):\n        if agent_dir.is_dir():\n            latest = get_latest_report(agent_dir)\n            if latest:\n                relative_path = latest.relative_to(report_dir)\n                agent_display = get_agent_name_from_path(latest) or agent_dir.name\n                lines.append(f\"- **{agent_display}**: [Latest Report]({relative_path})\")\n\n    if len(lines) == 2:\n        lines.append(\"_No reports found._\")\n        logger.warning(\"No agent reports found. Generated empty index.\")\n\n    index_file.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n    logger.info(f\"Index written to {index_file}\")\n</code></pre>"},{"location":"api/#civic_lib_core.report_reader","title":"report_reader","text":"<p>civic_lib_core/report_reader.py.</p> <p>Functions for reading, inspecting, and validating Civic Interconnect agent reports. Used by dashboards, CLI tools, and indexing utilities.</p>"},{"location":"api/#civic_lib_core.report_reader.get_latest_report","title":"get_latest_report","text":"<pre><code>get_latest_report(agent_dir: Path) -&gt; Path | None\n</code></pre> <p>Get the most recent report file from the specified agent directory.</p> <p>Parameters:</p> Name Type Description Default <code>agent_dir</code> <code>Path</code> <p>Path to the agent's report folder.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: The latest report file, or None if none found.</p> Source code in <code>src/civic_lib_core/report_reader.py</code> <pre><code>def get_latest_report(agent_dir: Path) -&gt; Path | None:\n    \"\"\"Get the most recent report file from the specified agent directory.\n\n    Args:\n        agent_dir (Path): Path to the agent's report folder.\n\n    Returns:\n        Path | None: The latest report file, or None if none found.\n    \"\"\"\n    report_files = sorted(\n        (f for f in agent_dir.glob(f\"*{REPORT_EXTENSION}\") if is_report_file(f)),\n        reverse=True,\n    )\n    latest = report_files[0] if report_files else None\n\n    if latest:\n        logger.debug(f\"Latest report for {agent_dir.name}: {latest.name}\")\n    else:\n        logger.warning(f\"No reports found in {agent_dir.name}\")\n\n    return latest\n</code></pre>"},{"location":"api/#civic_lib_core.report_reader.read_latest_report","title":"read_latest_report","text":"<pre><code>read_latest_report(agent_dir: Path, strict: bool = False) -&gt; dict[str, Any] | None\n</code></pre> <p>Read and return the contents of the latest report for a given agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_dir</code> <code>Path</code> <p>Path to the agent's report folder.</p> required <code>strict</code> <code>bool</code> <p>If True, raise errors on missing or invalid reports.            If False, return None and log a warning.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict | None: Parsed report contents, or None if no report exists or format is invalid (in non-strict mode).</p> Source code in <code>src/civic_lib_core/report_reader.py</code> <pre><code>def read_latest_report(agent_dir: Path, strict: bool = False) -&gt; dict[str, Any] | None:\n    \"\"\"Read and return the contents of the latest report for a given agent.\n\n    Args:\n        agent_dir (Path): Path to the agent's report folder.\n        strict (bool): If True, raise errors on missing or invalid reports.\n                       If False, return None and log a warning.\n\n    Returns:\n        dict | None: Parsed report contents, or None if no report exists or format is invalid (in non-strict mode).\n    \"\"\"\n    latest = get_latest_report(agent_dir)\n    if not latest:\n        msg = f\"No report found in {agent_dir}\"\n        if strict:\n            raise FileNotFoundError(msg)\n        logger.warning(msg)\n        return None\n\n    try:\n        data = json.loads(latest.read_text(encoding=\"utf-8\"))\n    except Exception as e:\n        msg = f\"Failed to read report: {latest} \u2014 {e}\"\n        if strict:\n            raise ValueError(msg) from e\n        logger.warning(msg)\n        return None\n\n    if not validate_report_format(data):\n        msg = f\"Invalid report format in: {latest}\"\n        if strict:\n            raise ValueError(msg)\n        logger.warning(msg)\n        return None\n\n    return data\n</code></pre>"},{"location":"api/#civic_lib_core.report_reader.validate_report_format","title":"validate_report_format","text":"<pre><code>validate_report_format(report: dict[str, Any]) -&gt; bool\n</code></pre> <p>Validate that a report contains all expected top-level keys.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>dict</code> <p>The parsed report to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if valid, False otherwise.</p> Source code in <code>src/civic_lib_core/report_reader.py</code> <pre><code>def validate_report_format(report: dict[str, Any]) -&gt; bool:\n    \"\"\"Validate that a report contains all expected top-level keys.\n\n    Args:\n        report (dict): The parsed report to validate.\n\n    Returns:\n        bool: True if valid, False otherwise.\n    \"\"\"\n    keys = set(report.keys())\n    missing = EXPECTED_REPORT_KEYS - keys\n    if missing:\n        logger.warning(f\"Report missing expected keys: {missing}\")\n        return False\n    return True\n</code></pre>"},{"location":"api/#civic_lib_core.report_summary","title":"report_summary","text":"<p>civic_lib_core/report_summary.py.</p> <p>Generates human-readable Markdown summaries of Civic Interconnect agent reports. Used optionally by agents or admin tools alongside JSON output.</p>"},{"location":"api/#civic_lib_core.report_summary.write_markdown_summary","title":"write_markdown_summary","text":"<pre><code>write_markdown_summary(report: dict[str, Any], path: Path) -&gt; None\n</code></pre> <p>Write a Markdown summary of a report's key metadata.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>dict</code> <p>The report data (already parsed).</p> required <code>path</code> <code>Path</code> <p>The output path to write the .md file.</p> required Source code in <code>src/civic_lib_core/report_summary.py</code> <pre><code>def write_markdown_summary(report: dict[str, Any], path: Path) -&gt; None:\n    \"\"\"Write a Markdown summary of a report's key metadata.\n\n    Args:\n        report (dict): The report data (already parsed).\n        path (Path): The output path to write the .md file.\n    \"\"\"\n    lines = [\n        f\"# Report Summary for {report.get('agent', 'Unknown Agent')}\",\n        f\"**Date:** {report.get('timestamp', 'Unknown')}\",\n        f\"**Agent Version:** {report.get('agent_version', 'N/A')}\",\n        f\"**Library Version:** {report.get('lib_version', 'N/A')}\",\n        f\"**Record Count:** {report.get('record_count', 'N/A')}\",\n        \"\",\n        \"Auto-generated summary. Data is available in the JSON report.\",\n    ]\n\n    # Ensure output folder exists\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    path.write_text(\"\\n\".join(lines), encoding=\"utf-8\")\n    logger.info(f\"Markdown summary written to {path}\")\n</code></pre>"},{"location":"api/#civic_lib_core.report_utils","title":"report_utils","text":"<p>civic_lib_core/report_utils.py.</p> <p>Basic helpers for working with Civic Interconnect reports. Part of the Civic Interconnect agent framework.</p>"},{"location":"api/#civic_lib_core.report_utils.get_agent_name_from_path","title":"get_agent_name_from_path","text":"<pre><code>get_agent_name_from_path(path: Path) -&gt; str\n</code></pre> <p>Extract and format the agent name from a report file path.</p> <p>The agent name is derived from the parent folder of the report file, with underscores replaced by spaces and title-cased.</p> <p>If the path does not have a parent directory, returns 'Unknown Agent'.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to a report file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted agent name or fallback string.</p> Source code in <code>src/civic_lib_core/report_utils.py</code> <pre><code>def get_agent_name_from_path(path: Path) -&gt; str:\n    \"\"\"Extract and format the agent name from a report file path.\n\n    The agent name is derived from the parent folder of the report file,\n    with underscores replaced by spaces and title-cased.\n\n    If the path does not have a parent directory, returns 'Unknown Agent'.\n\n    Args:\n        path (Path): The path to a report file.\n\n    Returns:\n        str: Formatted agent name or fallback string.\n    \"\"\"\n    name = path.parent.name\n    return name.replace(\"_\", \" \").title() if name else \"Unknown Agent\"\n</code></pre>"},{"location":"api/#civic_lib_core.report_utils.is_report_file","title":"is_report_file","text":"<pre><code>is_report_file(path: Path) -&gt; bool\n</code></pre> <p>Determine whether the given file path is a valid report file.</p> <p>A valid report file must: - Have a \".json\" extension - Begin with a date prefix (e.g., \"2024-01-01\")</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path matches report file format, False otherwise.</p> Source code in <code>src/civic_lib_core/report_utils.py</code> <pre><code>def is_report_file(path: Path) -&gt; bool:\n    \"\"\"Determine whether the given file path is a valid report file.\n\n    A valid report file must:\n    - Have a \".json\" extension\n    - Begin with a date prefix (e.g., \"2024-01-01\")\n\n    Args:\n        path (Path): The path to check.\n\n    Returns:\n        bool: True if the path matches report file format, False otherwise.\n    \"\"\"\n    if path.suffix != \".json\":\n        return False\n    try:\n        datetime.date.fromisoformat(path.stem[:10])\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/#civic_lib_core.report_writer","title":"report_writer","text":"<p>civic_lib_core/report_writer.py.</p> <p>Functions for writing timestamped agent reports in multiple formats. Used by daily Civic Interconnect agents.</p>"},{"location":"api/#civic_lib_core.report_writer.write_report","title":"write_report","text":"<pre><code>write_report(data: list[dict[str, Any]], agent_name: str, agent_version: str, schema_version: str = '1.0.0', report_dir: str | Path = REPORTS_DIR, file_format: str = 'json') -&gt; Path\n</code></pre> <p>Write agent output to a timestamped report file with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[dict[str, Any]]</code> <p>The results to include in the report.</p> required <code>agent_name</code> <code>str</code> <p>The name of the agent generating the report.</p> required <code>agent_version</code> <code>str</code> <p>The version of the agent code.</p> required <code>schema_version</code> <code>str</code> <p>The version of the report schema (default: \"1.0.0\").</p> <code>'1.0.0'</code> <code>report_dir</code> <code>str | Path</code> <p>Root directory where reports are saved (default: REPORTS_DIR).</p> <code>REPORTS_DIR</code> <code>file_format</code> <code>str</code> <p>Output format, one of \"json\" or \"csv\" (default: \"json\").</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The full path to the saved report file.</p> Source code in <code>src/civic_lib_core/report_writer.py</code> <pre><code>def write_report(\n    data: list[dict[str, Any]],\n    agent_name: str,\n    agent_version: str,\n    schema_version: str = \"1.0.0\",\n    report_dir: str | Path = REPORTS_DIR,\n    file_format: str = \"json\",\n) -&gt; Path:\n    \"\"\"Write agent output to a timestamped report file with metadata.\n\n    Args:\n        data (list[dict[str, Any]]): The results to include in the report.\n        agent_name (str): The name of the agent generating the report.\n        agent_version (str): The version of the agent code.\n        schema_version (str): The version of the report schema (default: \"1.0.0\").\n        report_dir (str | Path): Root directory where reports are saved (default: REPORTS_DIR).\n        file_format (str): Output format, one of \"json\" or \"csv\" (default: \"json\").\n\n    Returns:\n        Path: The full path to the saved report file.\n    \"\"\"\n    timestamp = now_utc_str(TIMESTAMP_FORMAT)\n    date_str = datetime.strptime(timestamp, TIMESTAMP_FORMAT).strftime(DATE_ONLY_FORMAT)\n\n    agent_folder = ensure_dir(Path(report_dir) / safe_filename(agent_name))\n    report_path = agent_folder / f\"{date_str}.{file_format}\"\n\n    if file_format == \"json\":\n        report = {\n            \"agent\": agent_name,\n            \"timestamp\": timestamp,\n            \"record_count\": len(data),\n            \"agent_version\": agent_version,\n            \"schema_version\": schema_version,\n            \"lib_version\": version_utils.get_repo_version(),\n            \"results\": data,\n        }\n        report_path.write_text(json.dumps(report, indent=2), encoding=\"utf-8\")\n\n    elif file_format == \"csv\":\n        report_formatter.to_csv(data, report_path)\n\n    else:\n        raise ValueError(f\"Unsupported report format: {file_format}\")\n\n    logger.info(f\"Report written: {report_path}\")\n    return report_path\n</code></pre>"},{"location":"api/#civic_lib_core.schema_utils","title":"schema_utils","text":"<p>civic_lib_core/schema_utils.py.</p> <p>Centralized schema change detection utilities for Civic Interconnect agents. Part of the Civic Interconnect agent framework.</p>"},{"location":"api/#civic_lib_core.schema_utils.detect_schema_change","title":"detect_schema_change","text":"<pre><code>detect_schema_change(old_file: Path, new_data: dict[str, Any]) -&gt; bool\n</code></pre> <p>Detect if the schema has changed by comparing the old file's hash with the new data.</p> <p>Parameters:</p> Name Type Description Default <code>old_file</code> <code>Path</code> <p>The path to the old schema file.</p> required <code>new_data</code> <code>dict[str, Any]</code> <p>The new schema data to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the schema has changed (i.e., hashes differ), False otherwise.</p> Source code in <code>src/civic_lib_core/schema_utils.py</code> <pre><code>def detect_schema_change(old_file: Path, new_data: dict[str, Any]) -&gt; bool:\n    \"\"\"Detect if the schema has changed by comparing the old file's hash with the new data.\n\n    Args:\n        old_file (Path): The path to the old schema file.\n        new_data (dict[str, Any]): The new schema data to compare against.\n\n    Returns:\n        bool: True if the schema has changed (i.e., hashes differ), False otherwise.\n    \"\"\"\n    if not old_file.exists():\n        logger.info(f\"Old schema file not found: {old_file}. Treating as changed.\")\n        return True\n\n    old_data = load_json(old_file)\n    changed = hash_dict(old_data) != hash_dict(new_data)\n    if changed:\n        logger.info(\"Schema change detected.\")\n    else:\n        logger.info(\"No schema change detected.\")\n    return changed\n</code></pre>"},{"location":"api/#civic_lib_core.schema_utils.hash_dict","title":"hash_dict","text":"<pre><code>hash_dict(data: dict[str, Any]) -&gt; str\n</code></pre> <p>Hash a JSON-serializable dictionary for change detection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dictionary to hash.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SHA-256 hash of the JSON-encoded dictionary.</p> Source code in <code>src/civic_lib_core/schema_utils.py</code> <pre><code>def hash_dict(data: dict[str, Any]) -&gt; str:\n    \"\"\"Hash a JSON-serializable dictionary for change detection.\n\n    Args:\n        data (dict[str, Any]): The dictionary to hash.\n\n    Returns:\n        str: The SHA-256 hash of the JSON-encoded dictionary.\n    \"\"\"\n    encoded = json.dumps(data, sort_keys=True).encode(\"utf-8\")\n    digest = hashlib.sha256(encoded).hexdigest()\n    logger.debug(f\"Computed hash: {digest}\")\n    return digest\n</code></pre>"},{"location":"api/#civic_lib_core.schema_utils.load_json","title":"load_json","text":"<pre><code>load_json(path: str | Path) -&gt; dict[str, Any]\n</code></pre> <p>Load a JSON file and return its contents as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The parsed JSON data.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>JSONDecodeError</code> <p>If the file is not valid JSON.</p> Source code in <code>src/civic_lib_core/schema_utils.py</code> <pre><code>def load_json(path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"Load a JSON file and return its contents as a dictionary.\n\n    Args:\n        path (str | Path): The path to the JSON file.\n\n    Returns:\n        dict[str, Any]: The parsed JSON data.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        json.JSONDecodeError: If the file is not valid JSON.\n    \"\"\"\n    path = Path(path)\n    with path.open(encoding=\"utf-8\") as f:\n        data = json.load(f)\n    logger.debug(f\"Loaded JSON from {path}\")\n    return data\n</code></pre>"},{"location":"api/#civic_lib_core.version_utils","title":"version_utils","text":"<p>civic_lib_core/version_utils.py.</p> <p>Version discovery utilities for Civic Interconnect projects.</p> <p>Supports: - Python projects (via importlib.metadata or pyproject.toml) - Non-Python projects (via VERSION file) - JavaScript/NodeJS projects (via package.json)</p> <p>This allows the Civic CLI and shared tools to work seamlessly across mixed technology stacks, ensuring consistent version handling even in frontend-only repos.</p>"},{"location":"api/#civic_lib_core.version_utils.get_repo_version","title":"get_repo_version","text":"<pre><code>get_repo_version(package_name: str = 'civic-lib-core', root_dir: Path | None = None) -&gt; str\n</code></pre> <p>Retrieve the project version from various sources.</p> <ol> <li>Python metadata (if package installed)</li> <li>pyproject.toml</li> <li>VERSION file</li> <li>package.json.</li> </ol> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The discovered version string, or \"0.0.0\" if none found.</p> Source code in <code>src/civic_lib_core/version_utils.py</code> <pre><code>def get_repo_version(\n    package_name: str = \"civic-lib-core\",\n    root_dir: Path | None = None,\n) -&gt; str:\n    \"\"\"Retrieve the project version from various sources.\n\n    1. Python metadata (if package installed)\n    2. pyproject.toml\n    3. VERSION file\n    4. package.json.\n\n    Returns:\n        str: The discovered version string, or \"0.0.0\" if none found.\n    \"\"\"\n    # 1. Check Python metadata\n    version_str = get_version_from_python_metadata(package_name)\n    if version_str:\n        return version_str\n\n    # 2. Determine root\n    try:\n        root = root_dir or fs_utils.get_project_root()\n    except Exception as e:\n        logger.warning(f\"Could not detect project root. Defaulting to cwd. Error: {e}\")\n        root = Path.cwd()\n\n    # 3. Check files in root\n    version_str = get_version_from_files(root)\n    if version_str:\n        return version_str\n\n    logger.info(\"No version found in repo. Defaulting to 0.0.0\")\n    return \"0.0.0\"\n</code></pre>"},{"location":"api/#civic_lib_core.version_utils.get_version_from_files","title":"get_version_from_files","text":"<pre><code>get_version_from_files(root: Path) -&gt; str | None\n</code></pre> <p>Check pyproject.toml, VERSION, or package.json for the project version.</p> Source code in <code>src/civic_lib_core/version_utils.py</code> <pre><code>def get_version_from_files(root: Path) -&gt; str | None:\n    \"\"\"Check pyproject.toml, VERSION, or package.json for the project version.\"\"\"\n    pyproject = root / \"pyproject.toml\"\n    if pyproject.exists():\n        try:\n            with pyproject.open(\"rb\") as f:\n                data = tomllib.load(f)\n            version_str = data.get(\"project\", {}).get(\"version\")\n            if version_str:\n                logger.info(f\"Version found in pyproject.toml: {version_str}\")\n                return version_str\n        except Exception as e:\n            logger.warning(f\"Error parsing pyproject.toml: {e}\")\n\n    version_file = root / \"VERSION\"\n    if version_file.exists():\n        try:\n            version_str = version_file.read_text(encoding=\"utf-8\").strip()\n            if version_str:\n                logger.info(f\"Version found in VERSION file: {version_str}\")\n                return version_str\n        except Exception as e:\n            logger.warning(f\"Error reading VERSION file: {e}\")\n\n    package_json = root / \"package.json\"\n    if package_json.exists():\n        try:\n            data = json.loads(package_json.read_text(encoding=\"utf-8\"))\n            version_str = data.get(\"version\")\n            if version_str:\n                logger.info(f\"Version found in package.json: {version_str}\")\n                return version_str\n        except Exception as e:\n            logger.warning(f\"Error reading package.json: {e}\")\n\n    return None\n</code></pre>"},{"location":"api/#civic_lib_core.version_utils.get_version_from_python_metadata","title":"get_version_from_python_metadata","text":"<pre><code>get_version_from_python_metadata(package_name: str) -&gt; str | None\n</code></pre> <p>Try reading the version from installed Python package metadata.</p> Source code in <code>src/civic_lib_core/version_utils.py</code> <pre><code>def get_version_from_python_metadata(package_name: str) -&gt; str | None:\n    \"\"\"Try reading the version from installed Python package metadata.\"\"\"\n    try:\n        version_str = get_python_version(package_name)\n        logger.info(f\"Version found via Python metadata: {version_str}\")\n        return version_str\n    except PackageNotFoundError:\n        logger.debug(f\"Package {package_name} not installed.\")\n    except Exception as e:\n        logger.warning(f\"Unexpected error reading Python version metadata: {e}\")\n    return None\n</code></pre>"},{"location":"cli/","title":"CLI Reference","text":""}]}