"""
civic_lib_core/doc_utils.py

Core development utilities.
Part of the Civic Interconnect agent framework.

MIT License — maintained by Civic Interconnect
"""

import ast
import importlib.util
import inspect
import sys
from pathlib import Path

import yaml

from civic_lib_core import log_utils
from civic_lib_core.file_utils import ensure_docs_output_dir, ensure_source_path

__all__ = [
    "build_api_nav",
    "dynamic_import_from_path",
    "extract_module_api",
    "extract_public_names",
    "find_public_classes",
    "find_public_functions",
    "generate_docs",
    "generate_api_docs",
    "generate_mkdocs_config",
    "generate_summary_yaml",
    "get_public_members",
    "normalize_formats",
    "parse_python_file",
    "extract_public_names",
    "publish_api_docs",
    "write_markdown_docs",
    "write_module_markdown",
    "write_yaml_summary",
]

log_utils.init_logger()
logger = log_utils.logger


def _detect_project_name(project_root: Path) -> str:
    return project_root.name.replace("-", " ").replace("_", " ").title()


def _get_index_content() -> str:
    s = """
# Civic Lib Core Documentation

Documentation for **Civic Lib Core**.

Use the navigation menu to explore available modules and APIs.

- The **API Reference** section includes autogenerated docs from the source code.
- This home page will always be served at `/`.

To learn more, visit the [GitHub repository](https://github.com/civic-interconnect/civic-lib-core).
"""
    return s.strip()


def build_api_nav(project_root: Path) -> list[dict[str, str]]:
    """
    Scan docs/api/ for .md files and build a flat MkDocs nav entry for each.
    """
    docs_api_path = project_root / "docs" / "api"
    if not docs_api_path.exists():
        logger.error(f"Missing expected path: {docs_api_path}")
        raise SystemExit(1)

    api_nav = []
    for md_file in sorted(docs_api_path.glob("*.md")):
        title = md_file.stem.replace("_", " ").title()
        api_nav.append({title: f"api/{md_file.name}"})

    if not api_nav:
        logger.error("No markdown files found in docs/api/. Navigation will be empty.")
        raise SystemExit(1)

    logger.info(f"Included {len(api_nav)} API modules in MkDocs navigation.")
    return api_nav


def dynamic_import_from_path(file_path: Path, module_name: str):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    if spec is None or spec.loader is None:
        raise ImportError(f"Cannot load {module_name} from {file_path}")
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module


def extract_module_api(source_path: Path) -> dict[str, dict]:
    """
    Recursively extract public functions and classes from Python source files.
    Returns a dict with module names as keys.
    """
    api_data = {}

    for py_file in source_path.rglob("*.py"):
        if py_file.name.startswith("_"):
            continue  # skip private modules like __init__.py

        rel_path = py_file.relative_to(source_path)
        module_name = ".".join(rel_path.with_suffix("").parts)

        try:
            module = dynamic_import_from_path(py_file, module_name)
            functions, classes = get_public_members(module)
            api_data[module_name] = {
                "functions": functions,
                "classes": classes,
            }
        except Exception as e:
            logger.warning(f"Skipped {py_file}: {e}")

    return api_data


def extract_public_names(tree: ast.AST) -> set[str]:
    """Extract names from __all__ declaration."""
    public_names = set()
    for node in ast.walk(tree):
        if (
            isinstance(node, ast.Assign)
            and any(isinstance(t, ast.Name) and t.id == "__all__" for t in node.targets)
            and isinstance(node.value, ast.List)
        ):
            public_names |= {elt.s for elt in node.value.elts if isinstance(elt, ast.Str)}
    return public_names


def find_public_classes(tree: ast.AST, public_names: set[str]) -> list[dict[str, str]]:
    """Find all public classes in the AST with their docstrings."""
    classes = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef) and (
            not node.name.startswith("_") or node.name in public_names
        ):
            # Extract docstring
            docstring = ast.get_docstring(node) or "No description available."

            # Get base classes
            bases = [ast.unparse(base) for base in node.bases] if node.bases else []
            inheritance = f"({', '.join(bases)})" if bases else ""

            classes.append({
                "name": node.name,
                "signature": f"{node.name}{inheritance}",
                "docstring": docstring,
            })

    return sorted(classes, key=lambda x: x["name"])


def find_public_functions(tree: ast.AST, public_names: set[str]) -> list[dict[str, str]]:
    """Find all public functions in the AST with their docstrings."""
    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and (
            not node.name.startswith("_") or node.name in public_names
        ):
            # Extract docstring
            docstring = ast.get_docstring(node) or "No description available."

            # Get function signature
            args = []
            for arg in node.args.args:
                args.append(arg.arg)

            # Add defaults
            defaults = (
                [ast.unparse(default) for default in node.args.defaults]
                if node.args.defaults
                else []
            )

            # Combine args with defaults
            signature_parts = []
            num_defaults = len(defaults)
            for i, arg in enumerate(args):
                if i >= len(args) - num_defaults:
                    default_idx = i - (len(args) - num_defaults)
                    signature_parts.append(f"{arg}={defaults[default_idx]}")
                else:
                    signature_parts.append(arg)

            signature = f"{node.name}({', '.join(signature_parts)})"

            functions.append({"name": node.name, "signature": signature, "docstring": docstring})

    return sorted(functions, key=lambda x: x["name"])


def generate_api_docs(source_dir_str: str = "civic_lib_core", output_dir_str: str = "api"):
    """Generate Markdown API documentation (backward compatibility)."""
    generate_docs(source_dir_str, output_dir_str, formats=["markdown"])


def generate_docs(
    source_pkg_str: str = "civic_lib_core",
    output_dir_str: str = "api",
    formats: str | list[str] | None = None,
):
    """
    Generate API documentation in multiple formats.
    """
    formats = normalize_formats(formats)
    logger.info(f"Generating API docs from {source_pkg_str} in formats: {formats}")

    source_path = ensure_source_path(source_pkg_str)
    output_dir = ensure_docs_output_dir(output_dir_str)
    api_data = extract_module_api(source_path)

    if not api_data:
        logger.warning("No public API found in source code")
        return

    if "yaml" in formats:
        write_yaml_summary(api_data, output_dir)

    if "markdown" in formats:
        write_markdown_docs(api_data, output_dir)


def generate_mkdocs_config(
    project_name: str | None = None, source_pkg_str: str = "civic_lib_core"
) -> None:
    """
    Generate mkdocs.yml configuration file with auto-discovered API docs.
    Scans docs/api for Markdown files and builds flat navigation.
    """
    from civic_lib_core.file_utils import find_project_root

    project_root = find_project_root()
    project_name = project_name or _detect_project_name(project_root)

    api_nav = build_api_nav(project_root)  # no api_data arg now

    if not api_nav:
        logger.error("No markdown files found in docs/api/. Navigation will be empty.")
        raise SystemExit(1)

    nav = [{"Home": "index.md"}, {"API Reference": api_nav}]

    config = {
        "site_name": f"{project_name} Documentation",
        "site_description": f"Documentation for {project_name}",
        "theme": {
            "name": "material",
            "palette": [{"scheme": "default", "primary": "indigo", "accent": "indigo"}],
            "features": [
                "navigation.expand",
            ],
        },
        "nav": nav,
        "plugins": ["search"],
        "markdown_extensions": ["toc", "codehilite", "admonition"],
    }

    config_path = project_root / "mkdocs.yml"
    with config_path.open("w", encoding="utf-8") as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    logger.info(f"MkDocs config written: {config_path}")
    write_index_md(project_root)


def generate_summary_yaml(source_pkg_str: str = "civic_lib_core", docs_output_string: str = "api"):
    """Generate YAML API summary (backward compatibility)."""
    generate_docs(source_pkg_str, docs_output_string, formats=["yaml"])


def get_public_members(module):
    functions = []
    classes = []

    for name, member in vars(module).items():
        if name.startswith("_"):
            continue

        if inspect.isfunction(member):
            try:
                sig = str(inspect.signature(member))
            except Exception:
                sig = "()"
            doc = inspect.getdoc(member) or "No description available."
            functions.append({"name": name, "signature": f"{name}{sig}", "docstring": doc})

        elif inspect.isclass(member):
            try:
                sig = str(inspect.signature(member.__init__))
            except Exception:
                sig = "()"
            doc = inspect.getdoc(member) or "No description available."
            classes.append({"name": name, "signature": f"{name}{sig}", "docstring": doc})

    return sorted(functions, key=lambda x: x["name"]), sorted(classes, key=lambda x: x["name"])


def normalize_formats(formats: str | list[str] | None) -> list[str]:
    """Ensure formats is a list of strings."""
    if formats is None:
        return ["yaml", "markdown"]

    if isinstance(formats, str):
        logger.warning(f"Expected list for 'formats' but got string: {formats!r}")
        return [formats]

    if not isinstance(formats, list) or not all(isinstance(f, str) for f in formats):
        raise TypeError(f"'formats' must be a list of strings, got: {formats!r}")

    return formats


def parse_python_file(file_path: Path) -> ast.AST | None:
    """Parse a Python file and return its AST, or None if there's a syntax error."""
    try:
        with open(file_path, encoding="utf-8") as f:
            return ast.parse(f.read(), filename=str(file_path))
    except SyntaxError as e:
        logger.warning(f"Syntax error in {file_path}: {e}")
        return None


def publish_api_docs(source_pkg_str: str = "civic_lib_core") -> None:
    """
    One-liner to generate complete API documentation for release.

    Generates YAML summary, Markdown docs, and MkDocs config in one call.
    Perfect for automated release workflows.

    Args:
        source_pkg_str: Source package to document (auto-detects project)
    """
    logger.info("Publishing API documentation...")
    try:
        # Force correct order
        generate_docs("civic_lib_core", formats=["yaml", "markdown"])
        generate_mkdocs_config(source_pkg_str="civic_lib_core")
        logger.info("API documentation published successfully")
    except Exception as e:
        logger.error(f"Error publishing API documentation: {e}")
        raise


def write_index_md(project_root: Path) -> None:
    """
    Write the index.md file to the docs/ folder with a standard welcome message.
    """
    docs_path = project_root / "docs"
    index_path = docs_path / "index.md"

    if not docs_path.exists():
        docs_path.mkdir(parents=True, exist_ok=True)

    with index_path.open("w", encoding="utf-8") as f:
        f.write(_get_index_content().strip() + "\n")

    logger.info(f"Wrote home page: {index_path}")


def write_markdown_docs(api_data: dict, output_dir: Path) -> None:
    """Write full Markdown docs for each module."""
    for module_name, module_data in api_data.items():
        if not isinstance(module_data, dict):
            logger.warning(f"Skipping {module_name} due to unexpected type: {type(module_data)}")
            continue

        functions = module_data.get("functions", [])
        classes = module_data.get("classes", [])
        md_path = output_dir / f"{module_name}.md"
        write_module_markdown(md_path, module_name, functions, classes)
        logger.debug(f"Wrote markdown: {md_path}")

    logger.info(f"Markdown API docs: {output_dir}")


def write_module_markdown(
    file_path: Path,
    module_name: str,
    functions: list[dict[str, str]],
    classes: list[dict[str, str]],
):
    """Write markdown documentation for a single module."""
    with file_path.open("w", encoding="utf-8") as out:
        out.write(f"# Module `{module_name}`\n\n")

        if classes:
            out.write("## Classes\n\n")
            for cls in classes:
                out.write(f"### `{cls['signature']}`\n\n")
                out.write(f"{cls['docstring']}\n\n")

        if functions:
            out.write("## Functions\n\n")
            for func in functions:
                out.write(f"### `{func['signature']}`\n\n")
                out.write(f"{func['docstring']}\n\n")


def write_yaml_summary(api_data: dict, output_dir: Path) -> None:
    """Write minimal YAML summary with module → [function names]."""
    minimal_yaml = {}
    for module_name, module_data in api_data.items():
        if isinstance(module_data, dict):
            functions = module_data.get("functions", [])
            if isinstance(functions, list):
                names = [f["name"] for f in functions if isinstance(f, dict) and "name" in f]
                if names:
                    minimal_yaml[module_name] = names

    yaml_path = output_dir / "API.yaml"
    with yaml_path.open("w", encoding="utf-8") as f:
        yaml.dump(minimal_yaml, f, sort_keys=True)

    logger.info(f"YAML API summary: {yaml_path}")


if __name__ == "__main__":
    publish_api_docs()
    logger.info("All documentation generated.")
